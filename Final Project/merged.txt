package gui.graph;

import datatypes.UDim2;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import processing.core.PApplet;
import processing.core.PFont;

public class PieChart extends Graphs
{
	private float sum;
	private float centerX;
	private float centerY;
	private int[] pieColors;
	private float[] arcValues;
	private float diameter;
	private float labelWidth;
	private float labelHeight;
	private int fontSize;
	private String[] labels;
	private boolean tweening;
	private boolean completedDraw;
	private boolean startedDraw;
	private int textColor;
	private int labelBackgroundColor;
	private boolean[] completedArc;
	private PFont labelFont, titleFont;

	public PieChart(Parent parent, UDim2 position, UDim2 size, int[] values, float labelWidth, String[] labels,
			String title)
	{
		super(parent, position, size, values, title);
		this.labels = labels;
		this.labelWidth = labelWidth;
		this.labelHeight = getHeight() / values.length;
		this.diameter = getHeight();
		this.values = values;
		tweening = false;
		completedDraw = false;
		startedDraw = false;
		sum = 0;
		for(float height : values)
			sum += height;

		centerX = getX() + diameter / 2 + labelWidth;
		centerY = getY() + diameter / 2;
		setBackgroundColor(0xFFFFFFFF);
		pieColors = new int[values.length];
		arcValues = new float[values.length];
		completedArc = new boolean[values.length];
		for(int i = 0; i < values.length; i++)
		{
			arcValues[i] = 0;
			completedArc[i] = false;
		}
		this.labelBackgroundColor = 0x0F000000;
		this.fontSize = 14;
		this.textColor = 0xFFFFFFFF;
		fontSize = fitFont(fontSize, findLargestLabel(labels), ((labelWidth - 10) / 2) * labelHeight);
		titleFont = applet.createFont("Calibri Bold", 20);
		labelFont = applet.createFont("Calibri Bold", fontSize);
		useLinearColours();
	}

	public PieChart(Parent parent, UDim2 position, UDim2 size, int[] values, float labelWidth, String[] labels)
	{
		this(parent, position, size, values, labelWidth, labels, "");
	}

	public void useLinearColours()
	{
		for(int i = 0; i < values.length; i++)
		{
			int redC = (int) PApplet.map(i, 0, values.length-1, 255, 0);
			int greenC = (int) PApplet.map(i, 0, values.length-1, 255, 0);
			int blueC = (int) PApplet.map(i, 0, values.length-1, 0, 255);
			pieColors[i] = applet.color(redC, greenC, blueC);
		}
	}

	public void useRandomColours()
	{
		for(int i = 0; i < values.length; i++)
		{
			pieColors[i] = applet.color(applet.random(256), applet.random(256), applet.random(256));
		}
	}

	public int[] getPieColors()
	{
		return this.pieColors;
	}

	public void setPieColors(int[] colors)
	{
		if(pieColors.length == colors.length) this.pieColors = colors;
	}

	public void setTextColor(int color)
	{
		this.textColor = color;
	}

	public void setLabelBackgroundColor(int color)
	{
		this.labelBackgroundColor = color;
	}

	public void setFontSize(int fontSize)
	{
		this.fontSize = fontSize;
	}

	public void displayPie()
	{
		float offset = 0;
		if(startedDraw || ! tweening || completedDraw)
		{
			startedDraw = true;
			for(int i = 0; i < values.length; i++)
			{
				applet.fill(pieColors[i]);
				float maxThisArc = (values[i] / sum) * PApplet.TWO_PI;

				float maxLastArc = 0;
				if(i != 0)
				{
					maxLastArc = (values[i - 1] / sum) * PApplet.TWO_PI;
				}

				if(i == 0) completedArc[i] = arcValues[i] == maxThisArc;
				else completedArc[i] = completedArc[i - 1] && arcValues[i] == maxThisArc;

				if(i == 0)
				{
					applet.arc(centerX, centerY, diameter, diameter, offset, offset + currentArc(i), PApplet.PIE);
				}
				else if(arcValues[i - 1] == maxLastArc && completedArc[i - 1])
				{
					applet.arc(centerX, centerY, diameter, diameter, offset, offset + currentArc(i), PApplet.PIE);
				}
				offset += maxThisArc;
			}
		}
		completedDraw = completedArc[values.length - 1];
	}

	public void displayText()
	{
		applet.noStroke();
		applet.fill(labelBackgroundColor);
		applet.rect(getX(), getY(), labelWidth - 10, getHeight());
		applet.textSize(fontSize * 2);
		applet.fill(textColor);
		applet.textFont(titleFont);
		applet.text(title, centerX, centerY - diameter / 2 - 50);
		applet.textSize(fontSize);
		applet.textFont(labelFont);
		for(int i = 0; i < pieColors.length && i < labels.length; i++)
		{
			applet.fill(textColor);
			applet.text(labels[i], getX(), getY() + i * labelHeight, (labelWidth - 10) / 2, labelHeight);
			applet.fill(pieColors[i]);
			applet.rect(getX() + (labelWidth / 2), getY() + i * labelHeight + labelHeight / 4, (labelWidth / 2) - 20,
					labelHeight / 2);
		}
	}

	private float currentArc(int i)
	{
		float maxArc = (values[i] / sum) * PApplet.TWO_PI;

		if(arcValues[i] < maxArc) arcValues[i] += 1f / PApplet.PI;
		if(arcValues[i] > maxArc) arcValues[i] = maxArc;
		return arcValues[i];
	}

	public void reset()
	{
		startedDraw = false;
		completedDraw = false;
		for(int i = 0; i < arcValues.length; i++)
		{
			arcValues[i] = 0;
			completedArc[i] = false;
		}
	}

	private void updatePosition()
	{
		float lastCenterX = centerX;
		float lastCenterY = centerY;

		centerX = getX() + diameter / 2 + labelWidth;
		centerY = getY() + diameter / 2;

		if(lastCenterX != centerX || lastCenterY != centerY) 
			tweening = true;
		else 
		 	tweening = false;
	}

	public void draw(GuiObject self)
	{
		if(visible)
		{
			updatePosition();
			applet.stroke(255);
			displayText();
			displayPie();
		}
	}
	
	public int[] getValues()
	{
		return values;
	}
	
	public boolean isTweening()
	{
		return tweening;
	}
	
	public boolean completedDrawing()
	{
		return completedDraw;
	}
	
	public String[] getLabels()
	{
		return labels;
	}
	
	public float[] getCenter()
	{
		return new float[] {centerX, centerY};
	}
}

package gui.graph;

import java.text.DecimalFormat;

import datatypes.UDim2;
import gui.primitive.Container;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import processing.core.PApplet;
import processing.core.PFont;

public class MultiLinechart extends Graphs 
{
	private Key chartKey;
	private int[] lineColors;
	
	private static final float ANIMATION_TIME = 2.5f;
	private static final int STROKE_SIZE = 2;

	float lineWidth;
	float lineHeightRatio;
	float labelSize;
	String[] leftLabels;
	String[] bottomLabels;
	int titleFontSize;
	int bottomLabelFontSize;
	int leftLabelFontSize;
	int textColor;
	int lineColor;
	int pointColor;
	float maxValue;
	float[] lineFraction;
	private float growthPerFrame;
	private String xLabel, yLabel;
	private int pointSize;
	private int[][] values;

	private PFont leftLabelFont;
	private PFont bottomLabelFont;
	private PFont titleFont;
	private static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("#");
	
	public MultiLinechart(Parent parent, UDim2 position, UDim2 size, float labelSize, String[] bottomLabels,
			String title, String xLabel, String yLabel,String[] keyLabels,int[] ...values)
	{
		super(parent, position, size, new int[0], title);
		lineColors = new int[values.length];
		chartKey = new Key(this,position,new UDim2(.25f,0f,.9f,0),keyLabels,lineColors);
		
		this.labelSize = labelSize;
		this.bottomLabels = bottomLabels;
		this.title = title;
		this.values = values;
		this.pointSize = 7;
		useLinearColours();
		
		lineFraction = new float[values[0].length - 1];
		for(int i = 0; i < lineFraction.length; i++)
		{
			lineFraction[i] = 0;
		}
		float totalFrames = ANIMATION_TIME * applet.frameRate;
		float framesPerSegment = totalFrames / values[0].length;
		growthPerFrame = 1 / framesPerSegment;

		lineWidth = (size.absoluteX()/2 - labelSize) / (this.values[0].length - 1);
		this.maxValue = 0;
		//use floats or double maxValue for double precision during division in graduateValues function later
		for(int[] line:values)
		{
			for(float value : line)
			{
				if(value > this.maxValue) maxValue = value;
			}
		}
		
		this.lineHeightRatio = ((size.absoluteY() - 2 * labelSize - 10) / maxValue);

		//default values
		titleFontSize = 20;
		leftLabelFontSize = 16;
		bottomLabelFontSize = 16;
		textColor = 0;
		lineColor = 0;
		pointColor = 0;

		titleFontSize = fitFont(titleFontSize, title, (size.absoluteX() - labelSize) * labelSize / 3);
		graduateValues(10);
		leftLabelFontSize = fitFont(leftLabelFontSize, findLargestLabel(leftLabels),
				((size.absoluteY() - 2 * labelSize) / leftLabels.length) * (labelSize * 2 / 3));
		bottomLabelFontSize = fitFont(bottomLabelFontSize, findLargestLabel(bottomLabels),
				lineWidth * (labelSize * 2 / 3));
		this.xLabel = xLabel;
		this.yLabel = yLabel;
		//P2d renderer so create all fonts before for clean text
		leftLabelFont = applet.createFont("Calibri Bold", leftLabelFontSize);
		bottomLabelFont = applet.createFont("Calibri Bold", bottomLabelFontSize);
		titleFont = applet.createFont("Calibri Bold", titleFontSize);
		
	}
	
	public void draw(GuiObject self)
	{
		float[] ordinates = getTruePosition();
		applet.fill(backgroundColor);
		applet.stroke(0);
		applet.rect(ordinates[0] + labelSize+size.absoluteX()/2,
				ordinates[1] + labelSize, 
				(size.absoluteX()/2) - labelSize,
				size.absoluteY() - (2 * labelSize));
		displayText();
		displayLines();
	}
	
	public void displayText()
	{
		float[] ordinates = getTruePosition();
		//processing.textSize(bottomLabelFontSize);
		applet.textFont(bottomLabelFont);
		applet.fill(textColor);
		applet.pushMatrix();
		applet.translate(
				ordinates[0] +size.absoluteX()/2+ labelSize - lineWidth / 2 + 
					(applet.textDescent() + applet.textDescent()) / 2,
				ordinates[1] + size.absoluteY() - labelSize / 3);
		int paddingRequired = (int) (((labelSize * 2 / 3) - applet.textWidth(findLargestLabel(bottomLabels)))
				/ paddingLength);
		for(int i = 0; i < bottomLabels.length; i++)
		{
			applet.rotate(PApplet.HALF_PI * 3);
			String label = bottomLabels[i];
			if(paddingRequired > 0) label = String.format("%" + - paddingRequired + "s", label);
			applet.text(label, 0, 0, (labelSize * 2 / 3), lineWidth);
			applet.rotate(- PApplet.HALF_PI * 3);
			applet.translate((lineWidth), 0);
		}
		applet.popMatrix();

		//processing.textSize(leftLabelFontSize);
		applet.textFont(leftLabelFont);
		for(int j = 0; j < leftLabels.length; j++)
		{
			String label = leftLabels[j];
			int leftPaddingRequired = (int) (((labelSize * 2 / 3) - applet.textWidth(label)) / paddingLength);
			if(paddingRequired > 0) label = String.format("%" + leftPaddingRequired + "s", label);

			applet.text(label, ordinates[0] + labelSize / 3 +size.absoluteX()/2,
					ordinates[1] + labelSize + ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) * j
							- ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) / 2, (labelSize * 2 / 3),
					(size.absoluteX() - 2 * labelSize) / leftLabels.length);
		}

		//processing.textSize(titleFontSize);
		applet.textFont(titleFont);
		applet.text(title, ordinates[0] + labelSize +size.absoluteX()/2,
				ordinates[1],
				size.absoluteX()/2 - labelSize,
				labelSize);

		applet.text(xLabel, 
				ordinates[0] +size.absoluteX()/2+labelSize, 
				ordinates[1] + getHeight() - labelSize / 3, 
				size.absoluteX()/2 - labelSize, 
				labelSize / 3);

		applet.pushMatrix();
		applet.translate(getX() +size.absoluteX()/2, getY() + getHeight());
		applet.rotate(PApplet.HALF_PI * 3);
		applet.text(yLabel, 0, 0, getHeight(), labelSize / 3);
		applet.rotate(- PApplet.HALF_PI * 3);
		applet.popMatrix();
	}
	
	public void displayLines()
	{
		applet.stroke(lineColor);
		applet.strokeWeight(STROKE_SIZE);
		float[] ordinates = getTruePosition();
		for(int j=0;j<values.length;j++)
		{
			applet.fill(lineColors[j]);
			applet.stroke(lineColors[j]);
			for(int i = - 1; i < values[j].length - 1; i++)
			{
				if(i >= 0)
				{
					if(i == 0) applet.ellipse((ordinates[0] + labelSize) + (i) * lineWidth+
								size.absoluteX()/2,
							ordinates[1] + (size.absoluteY() - 
									(values[j][i] * lineHeightRatio) - labelSize) - pointSize,
							pointSize, 
							pointSize);
					if(i == 0 || lineFraction[i - 1] == 1)
					{
						applet.line((ordinates[0] + labelSize) + (i) * lineWidth +size.absoluteX()/2,
								ordinates[1] + (size.absoluteY() - (values[j][i] * lineHeightRatio) - labelSize) - pointSize,
								(ordinates[0] + labelSize) + (i) * lineWidth + (lineWidth * (float) lineFraction[i])+size.absoluteX()/2,
								ordinates[1] + (size.absoluteY() - labelSize - (values[j][i] * lineHeightRatio)
										- (values[j][i + 1] - values[j][i]) * lineHeightRatio * (float) lineFraction[i])
										- pointSize);
						if(lineFraction[i] < 1)
						{
							lineFraction[i] += growthPerFrame;
							if(lineFraction[i] > 1) lineFraction[i] = 1;
						}
						else applet.ellipse((ordinates[0] + labelSize) + (i + 1) * lineWidth + size.absoluteX()/2,
								ordinates[1] + (size.absoluteY() - (values[j][i + 1] * lineHeightRatio) - labelSize)
								- pointSize, 
								pointSize, 
								pointSize);

					}
				}

			}
		}
	}
	
	public void useLinearColours()
	{
		
		for(int i = 0; i < values.length; i++)
		{
			int redC = (int) PApplet.map(i, 0, values.length-1, 255, 0);
			int greenC = (int) PApplet.map(i, 0, values.length-1, 255, 0);
			int blueC = (int) PApplet.map(i, 0, values.length-1, 0, 255);
			lineColors[i] = applet.color(redC, greenC, blueC);
		}
	}
	
	public void setBottomLabelFontSize(int bottomLabelFontSize)
	{
		this.bottomLabelFontSize = bottomLabelFontSize;
	}

	public void setLeftLabelFontSize(int leftLabelFontSize)
	{
		this.leftLabelFontSize = leftLabelFontSize;
	}

	public void setTextColor(int textColor)
	{
		this.textColor = textColor;
	}

	public void setLineColor(int lineColor)
	{
		this.lineColor = lineColor;
	}

	public void setPointColor(int pointColor)
	{
		this.pointColor = pointColor;
	}
	
	public void setLeftLabelFont(PFont font)
	{
		this.leftLabelFont = font;
	}

	public void setBottomLabelFont(PFont font)
	{
		this.bottomLabelFont = font;
	}

	public void setTitleFont(PFont font)
	{
		this.titleFont = font;
	}

	private final void graduateValues(int graduations)    //used in constructor only so final
	{
		leftLabels = new String[graduations];
		for(int i = 0; i < leftLabels.length; i++)
		{
			leftLabels[i] =NUMBER_FORMAT.format((maxValue - (maxValue / (leftLabels.length - 1)) * i)) + "";
		}
	}
	
	public void reset()
	{
		for(int i = 0; i < lineFraction.length; i++)
		{
			lineFraction[i] = 0;
		}
	}
	
	private class Key extends Container
	{
		String[] labels;
		int[] colors;
		private int labelBackgroundColor;
		private int textColor;
		private int fontSize;
		private float labelHeight;
		
		Key(Parent parent,UDim2 position,UDim2 size,String[] labels,int[] colors)
		{
			super(parent,position,size);
			this.labels=labels;
			this.colors=colors;
			this.labelBackgroundColor = 0x0F000000;
			this.textColor = 0xFFFFFFFF;
			this.labelHeight = size.absoluteY() / labels.length;
			fontSize = fitFont(14, findLargestLabel(labels), (size.absoluteX() / 2) * labelHeight);
		}
		
		public void draw(GuiObject self)
		{
			applet.noStroke();
			applet.fill(labelBackgroundColor);
			float[] ordinates = getTruePosition();
			applet.rect(ordinates[0], ordinates[1], size.absoluteX(), size.absoluteY());
			applet.textSize(fontSize);
			//displayTextVertically(labels,new UDim2(1f,size.absoluteX()/2,1f,0),new UDim2(.25f,0,1f,0));
			for(int i = 0; i < colors.length && i < labels.length; i++)
			{
				applet.fill(textColor);
				applet.text(labels[i], ordinates[0] + size.absoluteX()/2, ordinates[1] + i*labelHeight, 
						((size.absoluteX())/2) , labelHeight);
				applet.fill(colors[i]);
				applet.rect(ordinates[0] + 10, 	//raw offset left= 10
						ordinates[1] + i*labelHeight + labelHeight/4, //raw offset to position=labelheight/4
						(size.absoluteX()/2) - 20,	//20 = accomodate for offset left and right
						labelHeight/2);
			}
		}
	}
}
package gui.graph;

import java.text.DecimalFormat;

import datatypes.UDim2;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import processing.core.PApplet;
import processing.core.PFont;

public class LineChart extends Graphs
{
	private static final float ANIMATION_TIME = 2.5f;
	private static final int STROKE_SIZE = 2;

	float lineWidth;
	float lineHeightRatio;
	float labelSize;
	String[] leftLabels;
	String[] bottomLabels;
	int titleFontSize;
	int bottomLabelFontSize;
	int leftLabelFontSize;
	int textColor;
	int lineColor;
	int pointColor;
	float maxValue;
	float[] lineFraction;
	PApplet processing;
	private float growthPerFrame;
	private String xLabel, yLabel;
	private int pointSize;

	private PFont leftLabelFont;
	private PFont bottomLabelFont;
	private PFont titleFont;
	private static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("#");

	public LineChart(Parent parent, UDim2 position, UDim2 size, int[] values, float labelSize, String[] bottomLabels,
			String title, String xLabel, String yLabel)
	{
		super(parent, position, size, values, title);
		MouseEnter.disconnectAll();
		MouseLeave.disconnectAll();    //dont want default functionality for these
		this.processing = parent.getApplet();    //processing functions and methods are used frequently

		this.labelSize = labelSize;
		this.bottomLabels = bottomLabels;
		this.title = title;
		this.values = values;
		this.pointSize = 7;
		lineFraction = new float[values.length - 1];
		for(int i = 0; i < lineFraction.length; i++)
		{
			lineFraction[i] = 0;
		}
		float totalFrames = ANIMATION_TIME * processing.frameRate;
		float framesPerSegment = totalFrames / values.length;
		growthPerFrame = 1 / framesPerSegment;

		lineWidth = (size.absoluteX() - labelSize) / (this.values.length - 1);
		this.maxValue = 0;
		//use floats or double maxValue for double precision during division in graduateValues function later
		for(float value : values)
		{
			if(value > this.maxValue) maxValue = value;
		}
		this.lineHeightRatio = ((size.absoluteY() - 2 * labelSize - 10) / maxValue);

		//default values
		titleFontSize = 20;
		leftLabelFontSize = 16;
		bottomLabelFontSize = 16;
		textColor = 0;
		lineColor = 0;
		pointColor = 0;

		titleFontSize = fitFont(titleFontSize, title, (size.absoluteX() - labelSize) * labelSize / 3);
		graduateValues(10);
		leftLabelFontSize = fitFont(leftLabelFontSize, findLargestLabel(leftLabels),
				((size.absoluteY() - 2 * labelSize) / leftLabels.length) * (labelSize * 2 / 3));
		bottomLabelFontSize = fitFont(bottomLabelFontSize, findLargestLabel(bottomLabels),
				lineWidth * (labelSize * 2 / 3));
		this.xLabel = xLabel;
		this.yLabel = yLabel;
		//P2d renderer so create all fonts before for clean text
		leftLabelFont = applet.createFont("Calibri Bold", leftLabelFontSize);
		bottomLabelFont = applet.createFont("Calibri Bold", bottomLabelFontSize);
		titleFont = applet.createFont("Calibri Bold", titleFontSize);
	}

	public LineChart(Parent parent, UDim2 position, UDim2 size, int[] values, float labelSize, String[] bottomLabels,
			String title)
	{
		this(parent, position, size, values, labelSize, bottomLabels, title, "", "");
	}

	public void setLeftLabelFont(PFont font)
	{
		this.leftLabelFont = font;
	}

	public void setBottomLabelFont(PFont font)
	{
		this.bottomLabelFont = font;
	}

	public void setTitleFont(PFont font)
	{
		this.titleFont = font;
	}

	private final void graduateValues(int graduations)    //used in constructor only so final
	{
		leftLabels = new String[graduations];
		for(int i = 0; i < leftLabels.length; i++)
		{
			leftLabels[i] =NUMBER_FORMAT.format((maxValue - (maxValue / (leftLabels.length - 1)) * i)) + "";
		}
	}

	public final String findLargestLabel(String[] labels)
	{
		String largestLabel = "";
		for(String nextLabel : labels)
			largestLabel = largestText(largestLabel, nextLabel);
		return largestLabel;
	}

	public int fitFont(int maxFontSize, String text, double area)
	{
		int fontSize = maxFontSize;
		processing.textSize(fontSize);
		while((processing.textAscent() + processing.textDescent()) * processing.textWidth(text) > area && fontSize > 1)
		{
			fontSize--;
			processing.textSize(fontSize);
		}
		return fontSize;
	}

	public String largestText(String firstText, String secondText)
	{
		if(processing.textWidth(firstText) > processing.textWidth(secondText)) return firstText;
		return secondText;
	}

	public void reset()
	{
		for(int i = 0; i < lineFraction.length; i++)
		{
			lineFraction[i] = 0;
		}
	}

	public void displayLines()
	{
		processing.stroke(lineColor);
		processing.strokeWeight(STROKE_SIZE);
		processing.fill(pointColor);
		float[] ordinates = getTruePosition();
		for(int i = - 1; i < values.length - 1; i++)
		{
			if(i >= 0)
			{
				if(i == 0) processing.ellipse((ordinates[0] + labelSize) + (i) * lineWidth,
						ordinates[1] + (size.absoluteY() - (values[i] * lineHeightRatio) - labelSize) - pointSize,
						pointSize, pointSize);
				if(i == 0 || lineFraction[i - 1] == 1)
				{
					processing.line((ordinates[0] + labelSize) + (i) * lineWidth,
							ordinates[1] + (size.absoluteY() - (values[i] * lineHeightRatio) - labelSize) - pointSize,
							(ordinates[0] + labelSize) + (i) * lineWidth + (lineWidth * (float) lineFraction[i]),
							ordinates[1] + (size.absoluteY() - labelSize - (values[i] * lineHeightRatio)
									- (values[i + 1] - values[i]) * lineHeightRatio * (float) lineFraction[i])
									- pointSize);
					if(lineFraction[i] < 1)
					{
						lineFraction[i] += growthPerFrame;
						if(lineFraction[i] > 1) lineFraction[i] = 1;
					}
					else processing.ellipse((ordinates[0] + labelSize) + (i + 1) * lineWidth,
							ordinates[1] + (size.absoluteY() - (values[i + 1] * lineHeightRatio) - labelSize)
									- pointSize, pointSize, pointSize);

				}
			}

		}
	}

	public void setBottomLabelFontSize(int bottomLabelFontSize)
	{
		this.bottomLabelFontSize = bottomLabelFontSize;
	}

	public void setLeftLabelFontSize(int leftLabelFontSize)
	{
		this.leftLabelFontSize = leftLabelFontSize;
	}

	public void setTextColor(int textColor)
	{
		this.textColor = textColor;
	}

	public void setLineColor(int lineColor)
	{
		this.lineColor = lineColor;
	}

	public void setPointColor(int pointColor)
	{
		this.pointColor = pointColor;
	}

	public void displayText()
	{
		float[] ordinates = getTruePosition();
		//processing.textSize(bottomLabelFontSize);
		applet.textFont(bottomLabelFont);
		processing.fill(textColor);
		processing.pushMatrix();
		processing.translate(
				ordinates[0] + labelSize - lineWidth / 2 + (processing.textDescent() + processing.textDescent()) / 2,
				ordinates[1] + size.absoluteY() - labelSize / 3);
		int paddingRequired = (int) (((labelSize * 2 / 3) - applet.textWidth(findLargestLabel(bottomLabels)))
				/ paddingLength);
		for(int i = 0; i < bottomLabels.length; i++)
		{
			processing.rotate(PApplet.HALF_PI * 3);
			String label = bottomLabels[i];
			if(paddingRequired > 0) label = String.format("%" + - paddingRequired + "s", label);
			processing.text(label, 0, 0, (labelSize * 2 / 3), lineWidth);
			processing.rotate(- PApplet.HALF_PI * 3);
			processing.translate((lineWidth), 0);
		}
		processing.popMatrix();

		//processing.textSize(leftLabelFontSize);
		applet.textFont(leftLabelFont);
		for(int j = 0; j < leftLabels.length; j++)
		{
			String label = leftLabels[j];
			int leftPaddingRequired = (int) (((labelSize * 2 / 3) - applet.textWidth(label)) / paddingLength);
			if(paddingRequired > 0) label = String.format("%" + leftPaddingRequired + "s", label);

			processing.text(label, ordinates[0] + labelSize / 3,
					ordinates[1] + labelSize + ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) * j
							- ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) / 2, (labelSize * 2 / 3),
					(size.absoluteX() - 2 * labelSize) / leftLabels.length);
		}

		//processing.textSize(titleFontSize);
		applet.textFont(titleFont);
		processing.text(title, ordinates[0] + labelSize, ordinates[1], size.absoluteX() - labelSize, labelSize);

		applet.text(xLabel, getX(), getY() + getHeight() - labelSize / 3, getWidth(), labelSize / 3);

		applet.pushMatrix();
		applet.translate(getX(), getY() + getHeight());
		applet.rotate(PApplet.HALF_PI * 3);
		applet.text(yLabel, 0, 0, getHeight(), labelSize / 3);
		applet.rotate(- PApplet.HALF_PI * 3);
		applet.popMatrix();
	}

	@Override public void draw(GuiObject self)
	{
		//wont call super as dont want to implement default drawing functionality
		float[] ordinates = getTruePosition();
		processing.fill(backgroundColor);
		processing.stroke(0);
		processing.rect(ordinates[0] + labelSize, ordinates[1] + labelSize, size.absoluteX() - labelSize,
				size.absoluteY() - 2 * labelSize);
		displayLines();
		displayText();
	}
}
package gui.graph;

import java.text.DecimalFormat;

import datatypes.UDim2;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import processing.core.PApplet;
import processing.core.PFont;

public class Histograph extends Graphs
{
	private static final float ANIMATION_TIME = .5f;
	int[] barColors;
	float[] barHeights;
	float barWidth;
	float barHeightRatio;
	float labelSize;
	String[] leftLabels;
	String[] bottomLabels;

	int titleFontSize;
	int bottomLabelFontSize;
	int leftLabelFontSize;
	int colour;
	
	float maxValue;
	private int textColor;
	boolean defaultOrientation;
	private boolean startedDraw;
	private boolean tweening;
	private float[] truePosition;
	
	private String xLabel, yLabel;
	private PFont leftLabelFont;
	private PFont bottomLabelFont;
	private PFont titleFont;
	private static final DecimalFormat NUMBER_FORMAT = new DecimalFormat("#");

	public Histograph(Parent parent, UDim2 position, UDim2 size, int[] values, float labelSize, String[] bottomLabels,
			String title, int colour, String xLabel, String yLabel)
	{
		super(parent, position, size, values, title);
		this.xLabel = xLabel;
		this.yLabel = yLabel;
		this.truePosition = getTruePosition();
		startedDraw = false;
		this.colour = colour;
		this.labelSize = labelSize;
		this.bottomLabels = bottomLabels;
		barWidth = (getWidth() - labelSize) / (this.values.length);
		this.maxValue = 0;
		//use floats or double maxValue for double precision during division in graduateValues function later
		for(float value : values)
		{
			if(value > this.maxValue) maxValue = value;
		}
		this.barHeightRatio = ((getHeight() - 2 * labelSize) / maxValue);
		barColors = new int[this.values.length];
		barHeights = new float[values.length];

		setBarColors(colour);
		resetBarHeights();
		graduateValues();

		//default values
		titleFontSize = 20;
		leftLabelFontSize = 16;
		bottomLabelFontSize = 16;

		titleFontSize = fitFont(titleFontSize, title, (getWidth() - labelSize) * labelSize/3);
		leftLabelFontSize = fitFont(leftLabelFontSize, findLargestLabel(leftLabels),
				((getHeight() - 2 * labelSize) / leftLabels.length) * (labelSize*2/3));
		bottomLabelFontSize = fitFont(bottomLabelFontSize, findLargestLabel(bottomLabels), 
				barWidth * (labelSize*2/3));
		textColor = 0xFF000000;
		defaultOrientation=true;
		//P2d renderer so create all fonts before for clean text
		leftLabelFont = applet.createFont("Calibri Bold", leftLabelFontSize);
		bottomLabelFont = applet.createFont("Calibri Bold", bottomLabelFontSize);
		titleFont = applet.createFont("Calibri Bold", titleFontSize);
		
	}
	
	public Histograph(Parent parent, UDim2 position, UDim2 size, int[] values, float labelSize, String[] bottomLabels,
			String title, int colour)
	{
		this(parent, position, size, values, labelSize, bottomLabels, title, colour, "", "");
	}
	
	public void setLeftLabelFont(PFont font)
	{
		this.leftLabelFont=font;
	}
	
	public void setBottomLabelFont(PFont font)
	{
		this.bottomLabelFont=font;
	}
	
	public void setTitleFont(PFont font)
	{
		this.titleFont=font;
	}

	public void alternateOrientation()
	{
		defaultOrientation=false;
	}
	
	public void defaultOrientation()
	{
		defaultOrientation=true;
	}
	
	public int[] getValues()
	{
		return this.values;
	}

	public int[] getBarColors()
	{
		return barColors;
	}

	public int getNumberOfBars()
	{
		return this.values.length;
	}

	public float getMaxValue()
	{
		return maxValue;
	}

	@Deprecated //use reset barheights instead
	public void reset()
	{
		for(int i = 0; i < barHeights.length; i++)
		{
			barHeights[i] = 0;
		}
	}

	public void displayBars()
	{	
		if (truePosition[0] != getTruePosition()[0] || truePosition[1] != getTruePosition()[1])
		{
			tweening = true;
			updatePosition();
		}
		else
			tweening = false;
		
		if (startedDraw || !tweening)
		{
			startedDraw = true;
			for(int i = 0; i < values.length; i++)
			{
				applet.fill(barColors[i]);
				float height = thisBarHeight(i);
				applet.rect((getX() + labelSize) + i * barWidth,
						(getY() + labelSize) + (getHeight() - 2 * labelSize) - height, barWidth, height);
			}
		}
	}

	private float thisBarHeight(int barIndex)
	{
		double maxHeight = values[barIndex] * barHeightRatio;//getY() + (getHeight() - values[barIndex]*barHeightRatio);
		if(barHeights[barIndex] < maxHeight)
		{
			barHeights[barIndex] += maxHeight / (applet.frameRate*ANIMATION_TIME);
		}
		if(barHeights[barIndex] > (getHeight() - 2 * labelSize)) 
			barHeights[barIndex] = (getHeight() - 2 * labelSize);
		//System.out.println(maxHeight + ":" + getHeight() + ":" + barHeights[barIndex]);
		return barHeights[barIndex];
	}

	private final void graduateValues()    //used in constructor only so final
	{
		leftLabels = new String[10];
		for(int i = 0; i < leftLabels.length; i++)
		{
			leftLabels[i] =NUMBER_FORMAT.format((maxValue - (maxValue / (leftLabels.length - 1)) * i)) + "";
		}
	}

	public final void setBarColors(int newColour)
	{
		int[] shadesOfColour = {this.colour, brightenColour(this.colour)};
		for(int i = 0, shadeI = 0; i < values.length; i++, shadeI++)
		{
			if (shadeI >= shadesOfColour.length)
				shadeI -= shadesOfColour.length;
			barColors[i] = shadesOfColour[shadeI];
		}
	}
	
	public final void resetBarHeights()
	{
		startedDraw = false;
		for(int i = 0; i < values.length; i++)
		{
			barHeights[i] = 0;
		}
	}

	public final void setTextColor(int color)
	{
		this.textColor = color;
	}
	
	private void updatePosition()
	{
		truePosition = getTruePosition();
	}

	@Override public void draw(GuiObject self)
	{
		if(visible)
		{
			applet.fill(getBackgroundColor());
			applet.stroke(0);
			applet.rect(super.getX() + labelSize, super.getY() + labelSize, super.getWidth() - labelSize,
					super.getHeight() - 2 * labelSize);
			displayBars();

			applet.fill(textColor);
			//applet.textFont(font);
			//applet.textSize(bottomLabelFontSize);
			applet.textFont(bottomLabelFont);
			if(defaultOrientation)
			{
				applet.pushMatrix();
				applet.translate(getX() + labelSize + barWidth / 2 + (applet.textDescent() + applet.textDescent())/2,
						getY() + getHeight()-labelSize/3);
				int paddingRequired = (int) (((labelSize*2/3) - applet.textWidth(findLargestLabel(bottomLabels))) / paddingLength);
				for(int i = 0; i < bottomLabels.length; i++)
				{
					applet.rotate(PApplet.HALF_PI*3);
					String label = bottomLabels[i];
					if(paddingRequired > 0) 
						label = String.format("%" + - paddingRequired + "s", label);
					applet.text(label, 0, - barWidth / 2, (labelSize*2/3), barWidth);
					applet.rotate(- PApplet.HALF_PI*3);
					applet.translate((barWidth), 0);
				}
				applet.popMatrix();
			}
			else
			{
				displayTextHorizontally(bottomLabels,new UDim2(0,labelSize,0,getHeight()-labelSize),
						new UDim2(0,getWidth()-labelSize,0,labelSize));
			}

			//applet.textSize(leftLabelFontSize);
			applet.textFont(leftLabelFont);
			for(int j = 0; j < leftLabels.length; j++)
			{
				String label = leftLabels[j];
				int paddingRequired = (int) (((labelSize*2/3) - applet.textWidth(label)) / paddingLength);
				if(paddingRequired > 0) 
					label = String.format("%" + paddingRequired + "s", label);

				applet.text(label, 
						getX()+(labelSize/3),
						getY() + labelSize + ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) * j
							- ((getHeight() - 2 * labelSize) / (leftLabels.length - 1)) / 2, 
						(labelSize*2/3),
						(getHeight() - 2 * labelSize) / leftLabels.length);
			}

			//applet.textSize(titleFontSize);
			applet.textFont(titleFont);
			applet.text(title, getX() + labelSize, getY(), getWidth() - labelSize, labelSize);
			
			applet.text(xLabel, getX(),getY() + getHeight()-labelSize/3,getWidth(),labelSize/3);
			
			applet.pushMatrix();
			applet.translate(getX(),getY()+getHeight());
			applet.rotate(PApplet.HALF_PI*3);
			applet.text(yLabel, 0, 0,getHeight(),labelSize/3);
			applet.rotate(-PApplet.HALF_PI*3);
			applet.popMatrix();
		}
	}
}

package gui.graph;

import datatypes.UDim2;
import gui.primitive.Container;
import gui.primitive.Parent;
import processing.core.PApplet;

public abstract class Graphs extends Container
{
	protected int[] values;
	protected String title;
	PApplet applet;
	protected final float paddingLength;
	
	public Graphs(Parent parent, UDim2 position, UDim2 size, int[] values, String title)
	{
		super(parent,position,size);
		applet = parent.getApplet();
		MouseEnter.disconnectAll();
		MouseLeave.disconnectAll();
		this.values = values;
		this.title = title;
		paddingLength = applet.textWidth(" ");
	}
	
	public float getX()
	{
		float[] ordinates = getTruePosition();
		return ordinates[0];
	}
	
	public float getY()
	{
		float[] ordinates = getTruePosition();
		return ordinates[1];
	}
	
	public float getWidth()
	{
		return size.absoluteX();
	}
	
	public float getHeight()
	{
		return size.absoluteY();
	}
	
	public String findLargestLabel(String[] labels)
	{
		String largestLabel = "";
		for(String nextLabel:labels)
			largestLabel = largestText(largestLabel,nextLabel);
		return largestLabel;
	}

	public int fitFont(int maxFontSize,String text,double area)
	{
		int fontSize = maxFontSize;
		applet.textSize(fontSize);
		while((applet.textAscent()+applet.textDescent())*
				applet.textWidth(text)>area && fontSize>1)
		{
			fontSize--;
			applet.textSize(fontSize);
		}
		return fontSize;
	}

	public String largestText(String firstText,String secondText)
	{
		if(applet.textWidth(firstText)>applet.textWidth(secondText))
			return firstText;
		return secondText;
	}
	
	public void resetArray(float[] array)
	{
		for (int i = 0; i < array.length; i++)
		{
			array[i]=0;
		}
	}
	
	public void resetArray(int[] array)
	{
		for (int i = 0; i < array.length; i++)
		{
			array[i]=0;
		}
	}
	
	public void resetArray(double[] array)
	{
		for (int i = 0; i < array.length; i++)
		{
			array[i]=0;
		}
	}
	
	public void displayRotatedTextHorizontally(String[] text,UDim2 position,UDim2 size)
	{
		float[] origin = origin();
		float[] ordinates = {origin[0] + position.absoluteX(), origin[1] + position.absoluteY()};
		float labelWidth = size.absoluteX()/text.length;
		float labelHeight = size.absoluteY();
		
		applet.pushMatrix();
		applet.translate(ordinates[0],ordinates[1]);
		for(int i=0;i<text.length;i++)
		{
			applet.translate((labelWidth),0);
			applet.rotate(PApplet.HALF_PI);
			String label = text[i];
			
			int paddingRequired = (int)((labelHeight-applet.textWidth(label))/paddingLength);
			label = String.format("%" + -paddingRequired + "s", label);
			
			applet.text(label,0,0,labelHeight,labelWidth);
			applet.rotate(-PApplet.HALF_PI);
		}
		applet.popMatrix();	
	}
	
	public void displayRotatedTextVertically(String[] text,UDim2 position,UDim2 size)
	{
		float[] origin = origin();
		float[] ordinates = {origin[0] + position.absoluteX(), origin[1] + position.absoluteY()};
		float labelWidth = size.absoluteX()/text.length;
		float labelHeight = size.absoluteY();
		
		applet.pushMatrix();
		applet.translate(ordinates[0],ordinates[1]);
		for(int i=0;i<text.length;i++)
		{
			applet.translate(0,labelHeight);
			applet.rotate(PApplet.HALF_PI);
			String label = text[i];
			
			applet.text(label,0,0,labelHeight,labelWidth);
			applet.rotate(-PApplet.HALF_PI);
		}
		applet.popMatrix();	
	}
	
	public void displayTextVertically(String[] text,UDim2 position,UDim2 size)
	{
		float[] origin = origin();
		float[] ordinates = {origin[0] + position.absoluteX(), origin[1] + position.absoluteY()};
		float labelWidth = size.absoluteX()/text.length;
		float labelHeight = size.absoluteY();
		
		applet.pushMatrix();
		applet.translate(ordinates[0],ordinates[1]);
		for(int j=0;j<text.length;j++)
		{
			applet.translate(0,labelHeight);
			String label = text[j];
			int paddingRequired = (int)((labelWidth-applet.textWidth(label))/paddingLength);
			if(paddingRequired>0)
				label = String.format("%" + paddingRequired + "s", label);
			applet.text(label, 0,0,labelHeight,labelWidth);
		}
		applet.popMatrix();
	}
	
	public void displayTextHorizontally(String[] text,UDim2 position,UDim2 size)
	{
		float[] origin = origin();
		float[] ordinates = {origin[0] + position.absoluteX(), origin[1] + position.absoluteY()};
		float labelWidth = size.absoluteX()/text.length;
		float labelHeight = size.absoluteY();
		
		applet.pushMatrix();
		applet.translate(ordinates[0],ordinates[1]);
		for(int j=0;j<text.length;j++)
		{
			applet.text(text[j], 0,0,labelWidth,labelHeight);
			applet.translate(labelWidth,0);
		}
		applet.popMatrix();
	}
	
	protected int brightenColour(int colour)
	{
		int transparency = (colour & 0xFF000000) >> 24;
		int redComponent = colour & 0x000000FF;
		int greenComponent = (colour & 0x0000FF00) >> 8;
		int blueComponent = (colour & 0x00FF0000) >> 16;
		
		redComponent += 0x50;
		if (redComponent > 0xFF)
			redComponent = 0xFF;
		greenComponent += 0x50;
		if (greenComponent > 0xFF)
			greenComponent = 0xFF;
		blueComponent += 0x50;
		if (blueComponent > 0xFF)
			blueComponent = 0xFF;
		
		return (transparency << 24) + redComponent + (greenComponent << 8) + (blueComponent << 16);
	}

}
package gui.events;

import java.util.ArrayList;

public class Event {
	public interface EventOperation {
		public void run ();
	}
	
	protected ArrayList<EventOperation> connections = new ArrayList<EventOperation> ();
	
	public void connect (EventOperation operation) {
		connections.add(operation);
	}
	
	public void disconnect (EventOperation operation) {
		connections.remove(operation);
	}
	
	public void disconnectAll () {
		connections.clear();
	}
	
	public void trigger () {
		for (EventOperation operation: connections) {
			operation.run();
		}
	}
}package gui.primitive;

import java.util.ArrayList;

import datatypes.UDim2;
import middleware.Main;

public interface Parent {
	public float[] origin ();
	public UDim2 getSize ();
	
	public ArrayList<GuiObject> getChildren ();
	public GuiObject addChild (GuiObject child);
	public void removeChild (GuiObject child);
	public void clearAllChildren();
	public void clearAllChildren(int zIndex);
	
	public void changeZIndex (GuiObject child, int newZIndex);
	
	public Main getApplet ();
	public Screen getScreen ();
}package gui.primitive;

import datatypes.UDim2;
import gui.events.Event;

public class Container extends GuiObject {

	// Drawing properties
	protected int backgroundColor = 0xffffffff;
	
	protected boolean border 	 = true;
	protected boolean dynamicBorder = true;
	protected int inactiveBorderColor  = 0xff000000;
	protected int activeBorderColor = 0xffffffff;
	protected int borderColor = inactiveBorderColor;
	protected int borderThickness = 1;

	// Events
	protected boolean mouseInside = false;
	protected float[] lastMouse = {0,0};
	public final Event MouseEnter = new Event ();
	public final Event MouseLeave = new Event ();
	public final Event MouseMove  = new Event ();
	
	public Container (Parent parent, UDim2 position, UDim2 size) {
		super(parent, position, size);
		MouseEnter.connect(() -> borderColor = dynamicBorder ? activeBorderColor : borderColor);
		MouseLeave.connect(() -> borderColor = inactiveBorderColor);
	}

	public Container (Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	@Override
	public void update () {
		if (visible) {
			super.update();
			if (!tweening && applet.frame.getNextScreenId() == -1) {
				float lowerBoundX = getTruePosition()[0];
				float upperBoundX = lowerBoundX + size.absoluteX();
				float lowerBoundY = getTruePosition()[1];
				float upperBoundY = lowerBoundY + size.absoluteY();
				
				float mouseX = applet.mouseX;
				float mouseY = applet.mouseY;
				if (mouseInside && mouseX < lowerBoundX || mouseX > upperBoundX
				 || mouseY < lowerBoundY || mouseY > upperBoundY) {
					mouseInside = false;
					MouseLeave.trigger();
				} else if (mouseInside &&mouseX != lastMouse[0] || mouseY != lastMouse[1]) {
					MouseMove.trigger();
					lastMouse = new float[] {mouseX, mouseY};
				} else if (!mouseInside && mouseX > lowerBoundX && mouseX < upperBoundX
				       && mouseY > lowerBoundY && mouseY < upperBoundY) {
					mouseInside = true;
					MouseEnter.trigger();
				}
			}
		}
	}
	
	@Override
	public void draw(GuiObject self) {
		float [] drawPosition = getTruePosition();
		
		if (border) {
			applet.stroke(borderColor);
			applet.strokeWeight(borderThickness);
		} else {
			applet.noStroke();
		}
		
		applet.fill(backgroundColor);
		applet.rect(drawPosition[0], drawPosition[1], size.absoluteX(), size.absoluteY());
	}
	
	public void setBackgroundColor (int backgroundColor) {
		this.backgroundColor = backgroundColor;
	}
	
	public int getBackgroundColor () {
		return backgroundColor;
	}
	
	
	public void setBorder (boolean border) {
		this.border = border;
	}
	
	public boolean getBorder () {
		return border;
	}
	
	public void setBorderColor (int color) {
		this.borderColor = color;
		this.inactiveBorderColor = color;
	}
	
	public int getBorderColor () {
		return borderColor;
	}
	
	public void setActiveBorderColor (int color) {
		this.activeBorderColor = color;
	}
	
	public int getActiveBorderColor () {
		return this.activeBorderColor;
	}
	
	public void setDynamicBorder (boolean dynamicBorder) {
		this.dynamicBorder = dynamicBorder;
	}
	
	public boolean getDynamicBorder () {
		return this.dynamicBorder;
	}
	
	public void setBorderThickness (int thickness) {
		this.borderThickness = thickness < 1 ? 1 : thickness;
	}
	
	public int getBorderThickness () {
		return borderThickness;
	}
}
package gui.primitive;

import java.util.ArrayList;
import java.util.HashMap;

import datatypes.UDim2;
import middleware.Main;

public class Screen implements Parent {
	private static final float[] ORIGIN = {0f, 0f};
	private static int globalId = 0;
	public final int ID;
	
	private Main applet;
	private float[][] clippingRegion = {{0,0},{Main.SCREEN[0],Main.SCREEN[1]}};
	private HashMap<Integer, ArrayList<GuiObject>> children = new HashMap<Integer, ArrayList<GuiObject>> ();
	
	private boolean canBeChanged = true;
	
	public Screen (Main applet) {
		clearAllChildren();
		
		this.applet = applet;
		ID = globalId++;
	}
	
	public void draw () {
		for (int z = children.size() - 1; z >= 0; z--) {
			for (GuiObject child: children.get(z)) {
				child.draw();
			}
		}
	}
	
	public void update () {
		for (int z = children.size() - 1; z >= 0; z--) {
			for (GuiObject child: children.get(z)) {
				child.update();
			}
		}
	}

	public boolean canBeChanged () {
		return canBeChanged;
	}
	
	public void setCanBeChanged(boolean canBeChanged) {
		this.canBeChanged = canBeChanged;
	}
	
	public void setClippingRegion (float[][] region) {
		this.clippingRegion = region;
	}
	
	public float[][] getClippingRegion () {
		return clippingRegion;
	}
	
	@Override
	public float[] origin() {
		return ORIGIN;
	}
	
	@Override
	public ArrayList<GuiObject> getChildren() {
		ArrayList<GuiObject> allChildren = new ArrayList<GuiObject> ();
		
		for (int z = 0; z < children.size(); z++) {
			allChildren.addAll(allChildren.size(), children.get(z));
		}
		
		return allChildren;
	}
	
	@Override
	public GuiObject addChild (GuiObject child) {
		children.get(child.getZIndex()).add(child);
		return child;
	}
	
	@Override
	public void removeChild (GuiObject child) {
		children.get(child.getZIndex()).remove(child);
	}
	
	@Override 
	public void clearAllChildren () {
		for (int i = 0; i < GuiObject.ZLEVELS; i++) {
			children.put(i,  new ArrayList<GuiObject> ());
		}
	}
	
	@Override
	public void clearAllChildren (int zIndex) {
		children.put(zIndex, new ArrayList<GuiObject> ());
	}
	
	@Override
	public Main getApplet () {
		return applet;
	}

	@Override
	public Screen getScreen () {
		return this;
	}
	
	@Override
	public void changeZIndex (GuiObject child, int newZIndex) {
		children.get(child.getZIndex()).remove(child);
		children.get(newZIndex).add(child);
	}
	
	@Override
	public UDim2 getSize() {
		return new UDim2 (0f, (float) middleware.Main.SCREEN[0], 0f, (float) middleware.Main.SCREEN[1]);
	}
}
package gui.primitive;

import datatypes.UDim2;
import processing.core.PImage;

public class ImageLabel extends Container
{

	protected PImage image;

	public ImageLabel(Parent parent, UDim2 position, UDim2 size, PImage image)
	{
		super(parent, position, size);
		setImage(image);
	}

	public ImageLabel(Parent parent, UDim2 size, PImage image)
	{
		this(parent, new UDim2(), size, image);
	}

	@Override public void draw(GuiObject self)
	{
		super.draw(this);
		if(image != null)
		{
			float[] drawPosition = getTruePosition();
			applet.image(image, drawPosition[0], drawPosition[1]);
		}
	}

	public PImage getImage()
	{
		return image;
	}

	public void setImage(PImage image)
	{
		this.image = image;
		if(this.image != null) this.image.resize((int) size.absoluteX(), (int) size.absoluteY());
	}

}
package gui.primitive;

import java.util.HashMap;

import processing.core.PApplet;

public class Frame {
	private HashMap<Integer, Screen> screens = new HashMap <Integer, Screen> ();
	private Screen currentScreen;
	private int nextScreen = -1;
	private Screen backgroundScreen;
	private int backgroundColor = 0xff808080;
	
	private PApplet applet;
	
	public Frame (PApplet applet) {
		this.applet = applet;
	}
	
	public void draw () {
		if (nextScreen != -1) {
			if (currentScreen.canBeChanged()) {
				currentScreen = screens.get(nextScreen);
				nextScreen = -1;
			}
		}
		
		if (backgroundScreen == currentScreen && backgroundScreen != null) {
			backgroundScreen.update();
		} else {
			if (backgroundScreen != null) {
				backgroundScreen.draw();
			} else {
				applet.background(backgroundColor);
			}
			currentScreen.update();
		}
	}
	
	public Screen addScreen (Screen screen) {
		screens.put(screen.ID, screen);
		if (currentScreen == null)
			currentScreen = screen;
		return screen;
	}
	
	public void setCurrentScreen (int id) {
		nextScreen = id;
	}
	
	public Screen getCurrentScreen () {
		return currentScreen;
	}
	
	public Screen setBackgroundScreen (Screen screen) {
		return backgroundScreen = addScreen(screen);
	}
	
	public void setBackgroundColor (int color) {
		this.backgroundColor = color;
	}
	
	public int getBackgroundColor () {
		return this.backgroundColor;
	}
	
	public int getNextScreenId () {
		return nextScreen;
	}
}package gui.primitive;

import datatypes.UDim2;
import gui.events.Event;
import middleware.Main;

import java.util.ArrayList;
import java.util.HashMap;

public abstract  class GuiObject implements Parent {
	protected enum TweeningType {
		Position, Size, PositionAndSize;
	}
	
	public interface TweenCallback {
		public void execute ();
	}
	
	protected static final String NEGATIVE_SIZE_ERROR = "One of the components computes to negative or zero.";
	private static final String ZINDEX_OUT_OF_BOUNDS = "The ZIndex entered is out of bounds.";
	
	protected static Main applet;
	protected Screen screen;
	protected Parent parent;
	protected HashMap<Integer, ArrayList<GuiObject>> children = new HashMap<Integer, ArrayList<GuiObject>> ();
	
	protected UDim2 position;
	protected UDim2 size;
	
	protected static int tweenNumber = 0;
	
	protected boolean tweening = false;
	protected TweeningType type;
	protected UDim2 originalPosition;
	protected UDim2 destination;
	protected UDim2 originalSize;
	protected UDim2 finalSize;
	protected int duration;
	protected long startTime;
	protected TweenCallback callback;
	
	protected final Event SizeChange = new Event ();
	
	protected boolean visible = true;
	public static final int ZLEVELS = 10;
	protected int zIndex = 2;
	
	protected boolean clipDescendants = false;
	
	public GuiObject (Parent parent, UDim2 position, UDim2 size) {
		this.parent = parent;
		parent.addChild(this);
		applet = parent.getApplet();
		screen = parent.getScreen();
		
		clearAllChildren();
		
		setPosition(position);
		setSize(size);
		setZIndex(zIndex);
		SizeChange.connect(() -> {
			for (int z = children.size() - 1; z >= 0; z--) {
				for (GuiObject child: children.get(z)) {
					child.setPosition(child.position);
					child.setSize(child.size);
				}
			}
		});
	}
	
	public GuiObject (Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	public void draw () {
		tween();
		
		if (visible) {
			draw (this);
			for (int z = children.size() - 1; z >= 0; z--) {
				for (GuiObject child: children.get(z)) {
					child.draw();
				}
			}
		}
	}
	
	public abstract void draw (GuiObject self);
	
	public void update () {
		tween();
		if (visible) {
			draw (this);
			float[][] prevRegion = screen.getClippingRegion();
			if (clipDescendants) {
				float[] truePosition = getTruePosition();
				float[][] newRegion = {{truePosition[0]-1, truePosition[1]-1}, {size.absoluteX()+truePosition[0]+1, size.absoluteY()+truePosition[1]+1}};
	
				newRegion[0][0] = newRegion[0][0] < prevRegion[0][0] ? prevRegion[0][0] : newRegion[0][0];
				newRegion[0][1] = newRegion[0][1] < prevRegion[0][1] ? prevRegion[0][1] : newRegion[0][1];
				newRegion[1][0] = newRegion[1][0] > prevRegion[1][0] ? prevRegion[1][0] : newRegion[1][0];
				newRegion[1][1] = newRegion[1][1] > prevRegion[1][1] ? prevRegion[1][1] : newRegion[1][1];
	
				screen.setClippingRegion(newRegion);
				applet.clip(newRegion[0][0], newRegion[0][1], newRegion[1][0], newRegion[1][1]);
			}
			
			for (int z = children.size() - 1; z >= 0; z--) {
				for (GuiObject child: children.get(z)) {
					child.update();
				}
			}
			
			screen.setClippingRegion(prevRegion);
			applet.clip(prevRegion[0][0], prevRegion[0][1], prevRegion[1][0], prevRegion[1][1]);
		}
	}
	
	private void tween () {
		if (tweening) {
			long timeDifference = System.currentTimeMillis() - startTime;
			if (timeDifference <= duration) {
				float alpha = (float) timeDifference / (float) duration;
				if (type == TweeningType.Position || type == TweeningType.PositionAndSize)
					setPosition(originalPosition.lerp(destination, alpha));
				if (type == TweeningType.Size || type == TweeningType.PositionAndSize) {
					setSize(originalSize.lerp(finalSize, alpha));
				}
				if (callback != null) {
					callback.execute();
				}
			} else {
				screen.setCanBeChanged(true);
				tweening = false;
				callback = null;
				if (type == TweeningType.Position || type == TweeningType.PositionAndSize)
					setPosition(destination);
				if (type == TweeningType.Size || type == TweeningType.PositionAndSize)
					setSize(finalSize);
			}
		}
	}
	
	public void tweenPosition (UDim2 destination, float duration) {
		screen.setCanBeChanged(false);
		tweening = true;
		type = TweeningType.Position;
		originalPosition = position;
		this.destination = destination;
		this.duration = (int) (duration * 1000);
		startTime = System.currentTimeMillis();
	}
	
	public void tweenPosition (UDim2 destination, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenPosition(destination, duration);
	}
	
	public void tweenPosition (UDim2 originalPosition, UDim2 destination, float duration) {
		setPosition(originalPosition);
		tweenPosition(destination, duration);
	}
	
	public void tweenPosition (UDim2 originalPosition, UDim2 destination, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenPosition(originalPosition, destination, duration);
	}
	
	public void tweenSize (UDim2 finalSize, float duration) {
		screen.setCanBeChanged(false);
		tweening = true;
		type = TweeningType.Size;
		originalSize = size;
		this.finalSize = finalSize;
		this.duration = (int) (duration * 1000);
		startTime = System.currentTimeMillis();
	}
	
	public void tweenSize (UDim2 finalSize, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenSize(finalSize, duration);
	}
	
	public void tweenSize (UDim2 originalSize, UDim2 finalSize, float duration) {
		setSize(originalSize);
		tweenSize(finalSize, duration);
	}
	
	public void tweenSize (UDim2 originalSize, UDim2 finalSize, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenSize(originalSize, finalSize, duration);
	}
	
	public void tweenPositionAndSize (UDim2 destination, UDim2 finalSize, float duration) {
		screen.setCanBeChanged(false);
		tweening = true;
		type = TweeningType.PositionAndSize;
		originalPosition = position;
		originalSize = size;
		this.destination = destination;
		this.finalSize = finalSize;
		this.duration = (int) (duration * 1000);
		startTime = System.currentTimeMillis();
	}
	
	public void tweenPositionAndSize (UDim2 destination, UDim2 finalSize, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenPositionAndSize(destination, finalSize, duration);
	}
	
	public void tweenPositionAndSize (UDim2 originalPosition, UDim2 destination, UDim2 originalSize, UDim2 finalSize, float duration) {
		setPosition(originalPosition);
		setSize(originalSize);
		tweenPositionAndSize(destination, finalSize, duration);
	}
	
	public void tweenPositionAndSize (UDim2 originalPosition, UDim2 destination, UDim2 originalSize, UDim2 finalSize, float duration, TweenCallback callback) {
		this.callback = callback;
		tweenPositionAndSize(originalPosition, destination, originalSize, finalSize, duration);
	}
	
	public float[] getTruePosition () {
		float[] origin = parent.origin();
		float[] truePosition = {origin[0] + position.absoluteX(), origin[1] + position.absoluteY()};
		return truePosition;
	}
	
	public void setPosition (UDim2 position) {
		position.setScale(parent.getSize().toFloatArray());
		this.position = position;
	}
	
	public UDim2 getPosition () {
		return this.position;
	}
	
	public void setSize (UDim2 size) throws IllegalArgumentException {
		if (size.absoluteX() < 0 || size.absoluteY() < 0) {
			throw new IllegalArgumentException(NEGATIVE_SIZE_ERROR);
		} else {
			this.size = size;
			this.size.setScale(parent.getSize().toFloatArray());
			SizeChange.trigger();
		}
	}
	
	public UDim2 getSize () {
		return size;
	}
	
	public void setZIndex (int zIndex) throws IllegalArgumentException {
		if (zIndex < 0 || zIndex >= ZLEVELS)
			throw new IllegalArgumentException (ZINDEX_OUT_OF_BOUNDS);
		this.zIndex = zIndex;
		parent.changeZIndex(this, zIndex);
	}
	
	public int getZIndex () {
		return zIndex;
	}
	
	public void setVisible (boolean visible) {
		this.visible = visible;
	}
	
	public boolean getVisible () {
		return visible;
	}
	
	public void setClipDescendants (boolean clip) {
		this.clipDescendants = clip;
	}
	
	public boolean getClipDescendants () {
		return this.clipDescendants;
	}
	
	// Interface implementation
	@Override
	public float[] origin() {
		return getTruePosition();
	}

	@Override
	public ArrayList<GuiObject> getChildren() {
		ArrayList<GuiObject> allChildren = new ArrayList<GuiObject> ();
		
		for (int z = 0; z < children.size(); z++) {
			allChildren.addAll(allChildren.size(), children.get(z));
		}
		
		return allChildren;
	}
	
	@Override
	public GuiObject addChild (GuiObject child) {
		children.get(child.getZIndex()).add(child);
		return child;
	}
	
	@Override
	public void removeChild (GuiObject child) {
		children.get(child.getZIndex()).remove(child);
	}
	
	@Override 
	public void clearAllChildren () {
		for (int i = 0; i < GuiObject.ZLEVELS; i++) {
			children.put(i,  new ArrayList<GuiObject> ());
		}
	}
	
	@Override
	public void clearAllChildren (int zIndex) {
		children.put(zIndex, new ArrayList<GuiObject> ());
	}
	
	@Override
	public void changeZIndex (GuiObject child, int newZIndex) {
		children.get(child.getZIndex()).remove(child);
		children.get(newZIndex).add(child);
	}
	
	@Override
	public Main getApplet () {
		return applet;
	}
	
	@Override
	public Screen getScreen () {
		return screen;
	}
	
	public HashMap<Integer, ArrayList<GuiObject>> getZIndexChildren () {
		return children;
	}
}
package gui.primitive;

import datatypes.UDim2;
import gui.events.Event;

public class TextButton extends TextLabel {
	protected boolean mouseDown = false;
	protected static final int CLICK_PERIOD = 500; 		// In milliseconds.
	protected long mouseDownAt;
	public final Event MouseButton1Down  = new Event ();
	public final Event MouseButton1Up	 = new Event ();
	public final Event MouseButton1Click = new Event ();
	
	public TextButton (Parent parent, UDim2 position, UDim2 size, String text) {
		super(parent, position, size, text);
	}
	
	public TextButton (Parent parent, UDim2 size, String text) {
		this(parent, new UDim2 (), size, text);
	}
	
	@Override
	public void update () {
		super.update();
		if (visible) {
			if (mouseInside) {
				boolean isMouseDown = applet.mousePressed;
				if (mouseDown != isMouseDown) {
					mouseDown = isMouseDown;
					if (mouseDown) {
						mouseDownAt = System.currentTimeMillis();
						MouseButton1Down.trigger();
					} else {
						MouseButton1Up.trigger();
						if (System.currentTimeMillis() - mouseDownAt <= CLICK_PERIOD) {
							MouseButton1Click.trigger();
						}
					}
				}
			}
		}
	}
}package gui.primitive;

import datatypes.UDim2;
import middleware.Main;
import processing.core.PFont;

public class TextLabel extends Container {
	protected String text = "";
	protected int textColor = 0x00000000;
	protected int textSize = 14;
	protected int horizontalAlign = Main.CENTER;
	protected int verticalAlign = Main.CENTER;
	protected PFont font = applet.defaultFont;
	
	public TextLabel (Parent parent, UDim2 position, UDim2 size, String text) {
		super(parent, position, size);
		setText(text);

		setTextColor(0xffffffff);
		setBackgroundColor(0x00ffffff);
		setBorder(false);
	}
	
	public TextLabel (Parent parent, UDim2 size, String text) {
		this(parent, new UDim2 (), size, text);
	}
	
	@Override
	public void draw (GuiObject self) {
		try {
			super.draw(this);
			float[] drawPosition = getTruePosition();
			
			applet.fill(textColor);
			applet.textSize(textSize);
			applet.textAlign(horizontalAlign, verticalAlign);
			applet.textFont(font, textSize);
			applet.text(text, drawPosition[0], drawPosition[1], size.absoluteX(), size.absoluteY());
		} catch (Exception e) {
			
		}
	}
	
	public void setText (String text) {
		this.text = text;
	}
	
	public String getText () {
		return text;
	}
	
	public void setTextColor (int color) {
		this.textColor = color;
	}
	
	public int getTextColor () {
		return textColor;
	}
	
	public void setTextSize (int size) {
		this.textSize = size;
	}
	
	public int getTextSize () {
		return textSize;
	}
	
	public void setHorizontalAlign (int align) {
		this.horizontalAlign = align;
	}
	
	public int getHorizontalAlign () {
		return horizontalAlign;
	}
	
	public void setVerticalAlign (int align) {
		this.verticalAlign = align;
	}
	
	public int getVerticalAlign () {
		return verticalAlign;
	}
	
	public void setFont (PFont font) {
		this.font = font;
	}
}package gui.map;

import de.fhpotsdam.unfolding.UnfoldingMap;
import de.fhpotsdam.unfolding.geo.Location;
import de.fhpotsdam.unfolding.marker.SimplePointMarker;
import processing.core.PGraphics;

import java.util.HashMap;

public class InfoMarker extends SimplePointMarker
{

	private UnfoldingMap map;
	private float size;

	public InfoMarker(Location location, HashMap properties, UnfoldingMap map, int color)
	{
		super(location, properties);
		this.map = map;
		this.color = color;
		diameter = 7;
		size = diameter;
	}

	public void draw(PGraphics pg, float x, float y)
	{
		pg.pushStyle();
		pg.pushMatrix();
		if(selected) pg.translate(0, 0);
		pg.strokeWeight(strokeWeight);
		if(selected)
		{
			pg.fill(highlightColor);
			pg.stroke(highlightStrokeColor);
		}
		else
		{
			pg.fill(color);
			pg.stroke(strokeColor);
		}
		diameter = size * ((map.getZoomLevel() / 6f));
		pg.ellipse(x, y, diameter, diameter);
		pg.popMatrix();
		pg.popStyle();
	}

	public int getColor()
	{
		return color;
	}

}
package gui.map;

import database.Land;
import database.Queries;
import datatypes.UDim2;
import de.fhpotsdam.unfolding.UnfoldingMap;
import de.fhpotsdam.unfolding.events.EventDispatcher;
import de.fhpotsdam.unfolding.events.PanMapEvent;
import de.fhpotsdam.unfolding.events.ZoomMapEvent;
import de.fhpotsdam.unfolding.geo.Location;
import de.fhpotsdam.unfolding.marker.Marker;
import de.fhpotsdam.unfolding.marker.MarkerManager;
import de.fhpotsdam.unfolding.marker.SimplePointMarker;
import de.fhpotsdam.unfolding.providers.OpenStreetMap;
import de.fhpotsdam.unfolding.utils.MapUtils;
import gui.events.Event;
import gui.primitive.*;
import processing.core.PConstants;
import processing.core.PFont;
import processing.core.PImage;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;

public class Map extends Container
{
    private static final int CLICK_PERIOD = 500;
    private static final int FOCUS_ZOOM = 10;
    private static final int DEFAULT_ZOOM = 6;
    private static final int MIN_ZOOM = 5;
    private static final int MAX_ZOOM = 17;
    private static final int MAX_PANNING_DISTANCE = 600;
    private static final Location CENTRE_LOCATION = new Location(54.00366, -2.547855f);
    private static final int NUMBER_OF_MARKERS = 2500;
    public final Event MouseButton1Click = new Event();
    private final String STREET_VIEW = "https://maps.googleapis.com/maps/api/streetview?size=400x400&location=%f,%f&key=AIzaSyAX82YR3E81QTIG27I4X5Lx8ry7xOLNKX0";
    protected boolean mouseDown = false;
    protected long mouseDownAt;
    private boolean zoomingIntoAddress = false;
    private EventDispatcher eventDispatcher;
    private boolean active = true;

    private UnfoldingMap map;
    private InfoWindow markerInfoWindow, mapInfoWindow;
    private InfoMarker hitMarker, previousHitMarker;
    private MarkerManager markerManager;

    private PFont infoWindowNormalFont, infoWindowTitleFont, defaultFont;
    private UDim2[] infoWindowPositions = {new UDim2(1f, 0, 0, 0), new UDim2(0.85f, 0f, 0f, 0f)};
    private UDim2[] markerInfoWindowPositions = {new UDim2(1f, 0, 0, 0.5f), new UDim2(0.85f, -1f, 0f, 0.5f)};
    private HashMap<String, String> info;
    private Queries queries;
    private ArrayList<Integer> listOfIDs;

    private PImage histogramIcon, linePlotIcon, pieChartIcon;

    public Map(Parent parent, UDim2 position, UDim2 size, Queries queries, ArrayList<Integer> listOfIDs)
    {
        super(parent, position, size);
        this.queries = queries;
        this.listOfIDs = listOfIDs;
        this.info = this.queries.getMapDisplayInfo(listOfIDs);
        setZIndex(9);

        map = new UnfoldingMap(applet, getTruePosition()[0], getTruePosition()[1], size.absoluteX(), size.absoluteY(),
                new OpenStreetMap.OpenStreetMapProvider());
        markerManager = new MarkerManager();
        eventDispatcher = MapUtils.createDefaultEventDispatcher(applet, map);

        map.zoomAndPanTo(DEFAULT_ZOOM, CENTRE_LOCATION);
        map.setZoomRange(MIN_ZOOM, MAX_ZOOM);
        map.setTweening(true);
        map.setPanningRestriction(CENTRE_LOCATION, MAX_PANNING_DISTANCE);

        markerManager.addMarkers(getMarkers(this.queries.getLandObjects(listOfIDs)));
        map.addMarkerManager(markerManager);

        histogramIcon = applet.loadImage("img/Histogram-Icon.png");
        linePlotIcon = applet.loadImage("img/LinePlot-Icon.png");
        pieChartIcon = applet.loadImage("img/PieChart-Icon.png");

        markerInfoWindow = new InfoWindow(parent, markerInfoWindowPositions[0], new UDim2(0.15f, 0, 1, -1));
        if (info != null)
        {
            mapInfoWindow = new InfoWindow(parent, infoWindowPositions[1], new UDim2(0.15f, 0, 1, 0), info);
            mapInfoWindow.setBorder(false);
        }

        this.MouseButton1Click.connect(() -> mapPressed());

        infoWindowTitleFont = applet.boldFont;
        infoWindowNormalFont = applet.defaultFont;
        defaultFont = applet.defaultFont;

    }

    public void updateMap(ArrayList<Integer> listOfIDs)
    {
        markerManager.clearMarkers();
        this.listOfIDs = listOfIDs;
        this.info = this.queries.getMapDisplayInfo(listOfIDs);
        this.mapInfoWindow.updateInfo(info);
        this.mapInfoWindow.graphScreen.changeList(listOfIDs);
        markerManager.addMarkers(getMarkers(queries.getLandObjects(listOfIDs)));
        if (listOfIDs.size() == 1)
        {
            zoomingIntoAddress = true;
            mapPressed();
        }
    }

    public void draw(GuiObject self)
    {
        map.draw();
        if (parent.getClass().getName().equals("gui.primitive.Screen"))
        {
            if (applet.frame.getCurrentScreen() == parent) setActive(true);
            else setActive(false);
        }
    }

    public void setActive(boolean active)
    {
        if (active != this.active)
        {
            this.active = active;
            if (active) listen();
            else mute();
        }
    }

    public void listen()
    {
        eventDispatcher.register(map, PanMapEvent.TYPE_PAN, map.getId());
        eventDispatcher.register(map, ZoomMapEvent.TYPE_ZOOM, map.getId());
    }

    public void mute()
    {
        eventDispatcher.unregister(map, PanMapEvent.TYPE_PAN, map.getId());
        eventDispatcher.unregister(map, ZoomMapEvent.TYPE_ZOOM, map.getId());
    }

    @Override
    public void update()
    {
        super.update();
        if (mouseInside)
        {
            boolean isMouseDown = applet.mousePressed;
            if (mouseDown != isMouseDown)
            {
                mouseDown = isMouseDown;
                if (mouseDown) mouseDownAt = System.currentTimeMillis();
                else if (System.currentTimeMillis() - mouseDownAt <= CLICK_PERIOD) MouseButton1Click.trigger();
            }
        }
    }

    public void mapPressed()
    {
        if (map != null)
        {
            if (zoomingIntoAddress)
                hitMarker = (InfoMarker) markerManager.getMarkers().get(0);
            else
                hitMarker = (InfoMarker) map.getFirstHitMarker(applet.mouseX, applet.mouseY);
            if (hitMarker != null)
            {
                if (map.getZoomLevel() < FOCUS_ZOOM) map.zoomAndPanTo(FOCUS_ZOOM, hitMarker.getLocation());
                else map.panTo(hitMarker.getLocation());
                hitMarker.setSelected(true);
                markerInfoWindow.setMarker(hitMarker);
                if (markerInfoWindow.getPosition() != markerInfoWindowPositions[1])
                    markerInfoWindow.tweenPosition(markerInfoWindowPositions[0], markerInfoWindowPositions[1], 0.4f);
                if (mapInfoWindow.getPosition() != infoWindowPositions[0])
                    mapInfoWindow.tweenPosition(infoWindowPositions[1], infoWindowPositions[0], 0.4f);
                if (previousHitMarker != null & previousHitMarker != hitMarker) previousHitMarker.setSelected(false);
                previousHitMarker = hitMarker;
                zoomingIntoAddress = false;
            } else if (previousHitMarker != null)
            {
                if (previousHitMarker.isSelected())
                {
                    markerInfoWindow.tweenPosition(markerInfoWindowPositions[1], markerInfoWindowPositions[0], 0.4f);
                    mapInfoWindow.tweenPosition(infoWindowPositions[0], infoWindowPositions[1], 0.4f);
                }
                previousHitMarker.setSelected(false);
            }
        }
    }

    public ArrayList<Marker> getMarkers(Land[] lands)
    {
        ArrayList<Marker> markers = new ArrayList<>();
        ArrayList<Land> landList = new ArrayList<>(Arrays.asList(lands));
        Collections.shuffle(landList);
        for (int i = 0; i < landList.size() && i < NUMBER_OF_MARKERS; i++)
        {
            SimplePointMarker simplePointMarker = null;
            String type = landList.get(i).getPropertyType();
            if (type.equals(Land.DETACHED))
            {
                simplePointMarker = new InfoMarker(
                        new Location(landList.get(i).getLatitude(), landList.get(i).getLongitude()),
                        landList.get(i).getProperties(), map, applet.color(138, 202, 76));
            } else if (type.equals(Land.SEMI_DETACHED))
            {
                simplePointMarker = new InfoMarker(
                        new Location(landList.get(i).getLatitude(), landList.get(i).getLongitude()),
                        landList.get(i).getProperties(), map, applet.color(185, 115, 210));
            } else if (type.equals(Land.TERRACED))
            {
                simplePointMarker = new InfoMarker(
                        new Location(landList.get(i).getLatitude(), landList.get(i).getLongitude()),
                        landList.get(i).getProperties(), map, applet.color(187, 146, 55));
            } else if (type.equals(Land.FLATS_MAISONETTES))
            {
                simplePointMarker = new InfoMarker(
                        new Location(landList.get(i).getLatitude(), landList.get(i).getLongitude()),
                        landList.get(i).getProperties(), map, applet.color(226, 98, 94));
            } else if (type.equals(Land.OTHER))
            {
                simplePointMarker = new InfoMarker(
                        new Location(landList.get(i).getLatitude(), landList.get(i).getLongitude()),
                        landList.get(i).getProperties(), map, applet.color(207, 162, 70));
            }

            simplePointMarker.setStrokeColor(255);
            markers.add(simplePointMarker);
        }
        return markers;
    }

    private class InfoWindow extends Container
    {
        private InfoMarker marker;
        private HashMap<String, String> info;
        private ImageLabel image;
        private GraphScreen graphScreen;

        public InfoWindow(Parent parent, UDim2 position, UDim2 size, HashMap<String, String> info)
        {
            super(parent, position, size);
            this.info = info;
            setZIndex(9);

            this.MouseLeave.connect(() -> listen());
            this.MouseEnter.connect(() -> mute());

            if (info != null)
            {
                graphScreen = new GraphScreen(applet, queries, listOfIDs, info, applet.frame.getCurrentScreen().ID);
                applet.frame.addScreen(graphScreen);

                TextButton barChartButton = new TextButton(this, new UDim2(0.1f, 0, 0.92f, 0f),
                        new UDim2(0.2f, 0, 0.05f, 0), "");
                barChartButton.setTextSize(18);
                barChartButton.setBackgroundColor(0x2F000000);
                barChartButton.setTextColor(applet.TEXT_COLOR);
                barChartButton.setBorder(true);

                ImageLabel barchartIcon = new ImageLabel(this, new UDim2(0.13f, 0, 0.9275f, 0f),
                        new UDim2(0.145f, 0, 0.0375f, 0), histogramIcon);
                barchartIcon.setBorder(false);
                barchartIcon.setBackgroundColor(applet.TRANSPARENT);
                barchartIcon.MouseMove.disconnectAll();
                barchartIcon.MouseLeave.disconnectAll();
                barchartIcon.MouseEnter.disconnectAll();
                barchartIcon.setZIndex(8);

                barChartButton.MouseButton1Click.connect(graphScreen.toggleBarChart);

                TextButton pieChartButton = new TextButton(this, new UDim2(0.4f, 0, 0.92f, 0f),
                        new UDim2(0.2f, 0, 0.05f, 0), "");

                pieChartButton.setBackgroundColor(0x2F000000);
                pieChartButton.setTextColor(applet.TEXT_COLOR);
                pieChartButton.setBorder(true);
                pieChartButton.setTextSize(18);

                ImageLabel piechartIcon = new ImageLabel(this, new UDim2(0.43f, 0, 0.9275f, 0f),
                        new UDim2(0.145f, 0, 0.0375f, 0), pieChartIcon);
                piechartIcon.setBorder(false);
                piechartIcon.setBackgroundColor(applet.TRANSPARENT);
                piechartIcon.MouseMove.disconnectAll();
                piechartIcon.MouseLeave.disconnectAll();
                piechartIcon.MouseEnter.disconnectAll();
                piechartIcon.setZIndex(8);

                pieChartButton.MouseButton1Click.connect(graphScreen.togglePieChart);

                TextButton lineChartButton = new TextButton(this, new UDim2(0.7f, 0, 0.92f, 0f),
                        new UDim2(0.2f, 0, 0.05f, 0), "");

                lineChartButton.setBackgroundColor(0x2F000000);
                lineChartButton.setTextColor(applet.TEXT_COLOR);
                lineChartButton.setBorder(true);
                lineChartButton.setTextSize(18);
                lineChartButton.setZIndex(7);

                ImageLabel linechartIcon = new ImageLabel(this, new UDim2(0.725f, 0, 0.925f, 0f),
                        new UDim2(0.15f, 0, 0.04f, 0), linePlotIcon);
                linechartIcon.setBorder(false);
                linechartIcon.setBackgroundColor(applet.TRANSPARENT);
                linechartIcon.MouseMove.disconnectAll();
                linechartIcon.MouseLeave.disconnectAll();
                linechartIcon.MouseEnter.disconnectAll();
                linechartIcon.setZIndex(8);

                lineChartButton.MouseButton1Click.connect(graphScreen.toggleLineChart);
            } else
            {
                image = new ImageLabel(this, new UDim2(0.025f, 0, 0.005f, 0), new UDim2(0.95f, 0, 0.2f, 0), null);
                image.setBorder(false);
                image.MouseMove.disconnectAll();
                image.MouseLeave.disconnectAll();
                image.MouseEnter.disconnectAll();
                image.setZIndex(8);
            }
            setBackgroundColor(applet.BACKGROUND_COLOR);
        }

        public InfoWindow(Parent parent, UDim2 position, UDim2 size)
        {
            this(parent, position, size, null);
        }

        public void updateInfo(HashMap info)
        {
            this.info = info;
            graphScreen.changeInfo(info);
        }

        public void setMarker(InfoMarker marker)
        {
            this.marker = marker;
            String url = String.format(STREET_VIEW, marker.getLocation().getLat(), marker.getLocation().getLon());
            image.setImage(applet.loadImage(url, "jpg"));
            setBorderColor(marker.getColor());
            setBorderThickness(1);
            setDynamicBorder(false);
            setBackgroundColor(applet.BACKGROUND_COLOR);
            info = (HashMap) marker.getProperties();
        }

        @Override
        public void draw(GuiObject self)
        {
            if (info != null)
            {
                applet.textAlign(PConstants.CENTER);
                applet.textAlign(PConstants.CENTER);
                applet.fill(backgroundColor);
                if (border)
                {
                    applet.stroke(borderColor);
                    applet.strokeWeight(borderThickness);
                } else applet.noStroke();

                applet.rect(position.absoluteX(), position.absoluteY(), size.absoluteX(), size.absoluteY());
                applet.fill(applet.TEXT_COLOR);
                float x = position.absoluteX() + (size.absoluteX() / 2);
                float y = position.absoluteY();

                float division = size.absoluteY() / ((2 * info.size() + ((marker != null) ? 7 : 3)));
                if (marker != null) y += (6 * division);
                for (Object label : info.keySet())
                {
                    applet.textSize(applet.TITLE_TEXT_SIZE);
                    applet.textFont(infoWindowTitleFont);
                    y += division;
                    applet.textSize(applet.NORMAL_TEXT_SIZE - 2);
                    applet.text((String) label, x, y);
                    applet.textFont(infoWindowNormalFont);
                    y += division;
                    applet.textSize(applet.NORMAL_TEXT_SIZE - 3);
                    applet.text(info.get(label), x, y);
                }
                applet.textFont(defaultFont);
            }
        }
    }

}
package gui.map;

import database.DiscreteData;
import database.Land;
import database.Queries;
import datatypes.UDim2;
import gui.events.Event;
import gui.graph.Histograph;
import gui.graph.LineChart;
import gui.graph.PieChart;
import gui.primitive.Container;
import gui.primitive.Screen;
import gui.primitive.TextButton;
import middleware.Main;

import java.util.ArrayList;
import java.util.HashMap;

public class GraphScreen extends Screen
{
    public final UDim2[] CONTAINER_POSITIONS = {new UDim2(-0.6f, 0, 0.05f, 0), new UDim2(0f, 0f, 0.05f, 0f)};
    private final UDim2 CHART_POSITION = new UDim2(0.1f, 0, 0.05f, 0);
    private final UDim2 PIE_CHART_POSITION = new UDim2(0.1f, 0, 0.135f, 0);
    private final UDim2 CHART_SIZE = new UDim2(0.8f, 0, 0.85f, 0);
    private final UDim2 PIE_CHART_SIZE = new UDim2(0.725f, 0, 0.725f, 0);
    private Container container;
    private Histograph priceHistograph, monthHistograph, dateHistograph = null;
    private PieChart typePieChart, conditionPieChart = null;
    private LineChart monthLineChart, monthAverageLineChart, dateLineChart, dateAverageLineChart = null;
    private Queries queries;
    private ArrayList<Integer> listOfIDs;
    Event.EventOperation togglePieChart = () ->
    {
        if (container != null && container.getPosition() == CONTAINER_POSITIONS[0])
        {
            setupPieCharts();
            getApplet().frame.setCurrentScreen(this.ID);
            container.tweenPosition(CONTAINER_POSITIONS[1], 0.4f);

            TextButton propertyTypeButton = new TextButton(container, new UDim2(0.1f, 0f, 0.925f, 0f),
                    new UDim2(0.35f, 0, 0.04f, 0), "Types of Property Sold");
            propertyTypeButton.setTextSize(14);
            propertyTypeButton.setBackgroundColor(0x2F000000);
            propertyTypeButton.setTextColor(255);
            propertyTypeButton.setBorder(true);
            propertyTypeButton.setZIndex(1);

            Event.EventOperation showPropertyGraph = () ->
            {
                conditionPieChart.setVisible(false);
                typePieChart.setVisible(true);
                typePieChart.reset();
            };

            propertyTypeButton.MouseButton1Click.connect(showPropertyGraph);
            propertyTypeButton.MouseButton1Click.trigger();

            TextButton conditionButton = new TextButton(container, new UDim2(0.55f, 0f, 0.925f, 0f),
                    new UDim2(0.35f, 0, 0.04f, 0), "Condition of Property Sold");
            conditionButton.setTextSize(14);
            conditionButton.setBackgroundColor(0x2F000000);
            conditionButton.setTextColor(255);
            conditionButton.setBorder(true);
            conditionButton.setZIndex(1);

            Event.EventOperation showConditionGraph = () ->
            {
                conditionPieChart.setVisible(true);
                typePieChart.setVisible(false);
                conditionPieChart.reset();
            };

            conditionButton.MouseButton1Click.connect(showConditionGraph);
        }
    };
    Event.EventOperation toggleLineChart = () ->
    {
        if (container != null && container.getPosition() == CONTAINER_POSITIONS[0])
        {
            setupLineCharts();
            getApplet().frame.setCurrentScreen(this.ID);
            container.tweenPosition(CONTAINER_POSITIONS[1], 0.4f);

            TextButton monthDataButton = new TextButton(container, new UDim2(0.15f, 0f, 0.925f, 0f),
                    new UDim2(0.15f, 0, 0.04f, 0), "Sales By Month");
            monthDataButton.setTextSize(14);
            monthDataButton.setBackgroundColor(0x2F000000);
            monthDataButton.setTextColor(255);
            monthDataButton.setBorder(true);
            monthDataButton.setZIndex(1);

            Event.EventOperation showMonthGraph = () ->
            {
                monthAverageLineChart.setVisible(false);
                dateAverageLineChart.setVisible(false);
                dateLineChart.setVisible(false);
                monthLineChart.setVisible(true);
                monthLineChart.reset();
            };

            monthDataButton.MouseButton1Click.connect(showMonthGraph);
            monthDataButton.MouseButton1Click.trigger();

            TextButton monthAverageButton = new TextButton(container, new UDim2(0.35f, 0f, 0.925f, 0f),
                    new UDim2(0.15f, 0, 0.04f, 0), "Price by Month");
            monthAverageButton.setTextSize(14);
            monthAverageButton.setBackgroundColor(0x2F000000);
            monthAverageButton.setTextColor(255);
            monthAverageButton.setBorder(true);
            monthAverageButton.setZIndex(1);

            Event.EventOperation showMonthAverageGraph = () ->
            {
                monthAverageLineChart.setVisible(true);
                dateAverageLineChart.setVisible(false);
                dateLineChart.setVisible(false);
                monthLineChart.setVisible(false);
                monthAverageLineChart.reset();
            };

            monthAverageButton.MouseButton1Click.connect(showMonthAverageGraph);

            TextButton dateButton = new TextButton(container, new UDim2(0.55f, 0f, 0.925f, 0f),
                    new UDim2(0.15f, 0, 0.04f, 0), "Sales by Date");
            dateButton.setTextSize(14);
            dateButton.setBackgroundColor(0x2F000000);
            dateButton.setTextColor(255);
            dateButton.setBorder(true);
            dateButton.setZIndex(1);

            Event.EventOperation showDateGraph = () ->
            {
                monthAverageLineChart.setVisible(false);
                dateAverageLineChart.setVisible(false);
                dateLineChart.setVisible(true);
                monthLineChart.setVisible(false);
                dateLineChart.reset();
            };

            dateButton.MouseButton1Click.connect(showDateGraph);

            TextButton dateAverageButton = new TextButton(container, new UDim2(0.75f, 0f, 0.925f, 0f),
                    new UDim2(0.15f, 0, 0.04f, 0), "Price by Date");
            dateAverageButton.setTextSize(14);
            dateAverageButton.setBackgroundColor(0x2F000000);
            dateAverageButton.setTextColor(255);
            dateAverageButton.setBorder(true);
            dateAverageButton.setZIndex(1);

            Event.EventOperation showDateAverageGraph = () ->
            {
                monthAverageLineChart.setVisible(false);
                dateAverageLineChart.setVisible(true);
                dateLineChart.setVisible(false);
                monthLineChart.setVisible(false);
                dateAverageLineChart.reset();
            };

            dateAverageButton.MouseButton1Click.connect(showDateAverageGraph);
        }
    };
    private boolean entered;
    private HashMap<String, String> info;
    private DiscreteData priceData, monthSalesData, typeData, dateData, propertyData, monthAverageData, dateAverageData;
    public Event.EventOperation toggleBarChart = () ->
    {
        if (container != null && container.getPosition() == CONTAINER_POSITIONS[0])
        {
            setupHistographs();
            getApplet().frame.setCurrentScreen(this.ID);
            container.tweenPosition(CONTAINER_POSITIONS[1], 0.4f);

            TextButton priceButton = new TextButton(container, new UDim2(0.1f, 0f, 0.925f, 0f),
                    new UDim2(0.2f, 0, 0.04f, 0), "Price");
            priceButton.setTextSize(14);
            priceButton.setBackgroundColor(0x2F000000);
            priceButton.setTextColor(255);
            priceButton.setBorder(true);
            priceButton.setZIndex(1);

            Event.EventOperation showPriceGraph = () ->
            {
                dateHistograph.setVisible(false);
                monthHistograph.setVisible(false);
                priceHistograph.setVisible(true);
                priceHistograph.resetBarHeights();
            };

            priceButton.MouseButton1Click.connect(showPriceGraph);
            priceButton.MouseButton1Click.trigger();

            TextButton monthSalesButton = new TextButton(container, new UDim2(0.4f, 0f, 0.925f, 0f),
                    new UDim2(0.2f, 0, 0.04f, 0), "Month");
            monthSalesButton.setTextSize(14);
            monthSalesButton.setBackgroundColor(0x2F000000);
            monthSalesButton.setTextColor(255);
            monthSalesButton.setBorder(true);
            monthSalesButton.setZIndex(1);

            Event.EventOperation showPropertyGraph = () ->
            {
                dateHistograph.setVisible(false);
                monthHistograph.setVisible(true);
                priceHistograph.setVisible(false);
                monthHistograph.resetBarHeights();
            };

            monthSalesButton.MouseButton1Click.connect(showPropertyGraph);

            TextButton dateSalesButton = new TextButton(container, new UDim2(0.7f, 0f, 0.925f, 0f),
                    new UDim2(0.2f, 0, 0.04f, 0), "Time");
            dateSalesButton.setTextSize(14);
            dateSalesButton.setBackgroundColor(0x2F000000);
            dateSalesButton.setTextColor(255);
            dateSalesButton.setBorder(true);
            dateSalesButton.setZIndex(1);

            Event.EventOperation showConditionGraph = () ->
            {
                dateHistograph.setVisible(true);
                monthHistograph.setVisible(false);
                priceHistograph.setVisible(false);
                dateHistograph.resetBarHeights();
            };

            dateSalesButton.MouseButton1Click.connect(showConditionGraph);
        }
    };

    public GraphScreen(Main applet, Queries queries, ArrayList<Integer> listOfIDs, HashMap info, int mainID)
    {
        super(applet);
        this.queries = queries;
        this.listOfIDs = listOfIDs;
        this.info = info;
        container = new Container(this, CONTAINER_POSITIONS[0], new UDim2(0.6f, 0, 0.9f, 0));
        container.setBackgroundColor(applet.BACKGROUND_COLOR);
        container.setBorder(false);
        entered = false;

        Event.EventOperation closeGraphScreen = () ->
        {
            if (entered)
            {
                container.clearAllChildren();

                container.tweenPosition(CONTAINER_POSITIONS[0], 0.4f);
                applet.frame.setCurrentScreen(mainID);
                entered = false;
            }
        };

        container.MouseEnter.connect(() -> entered = true);
        container.MouseLeave.connect(closeGraphScreen);
    }

    public void changeList(ArrayList<Integer> listOfIDs)
    {
        this.listOfIDs = listOfIDs;
        container.clearAllChildren();
        priceData = null;
        monthSalesData = null;
        typeData = null;
        dateData = null;
        propertyData = null;
        monthAverageData = null;
        dateAverageData = null;
    }

    public void changeInfo(HashMap info)
    {
        this.info = info;
    }

    public void setupHistographs()
    {
        if (priceData == null)
            priceData = queries.priceDiscreteData(listOfIDs, Integer.parseInt(info.get("Minimum Price").replaceFirst(".", "")),
                    Integer.parseInt(info.get("Maximum Price").replaceFirst(".", "")), 30);
        priceHistograph = new Histograph(container, CHART_POSITION, CHART_SIZE,
                priceData.getData(), 120, priceData.getLabels(), priceData.getTitle(), 0xcF317873, "Price ()", "Number of Sales");
        priceHistograph.setBackgroundColor(0x3FFFFFFF);
        priceHistograph.setVisible(false);
        priceHistograph.setTextColor(0xFFFFFFFF);

        if (monthSalesData == null)
            monthSalesData = queries.monthSalesDiscreteData(listOfIDs);
        monthHistograph = new Histograph(container, CHART_POSITION, CHART_SIZE,
                monthSalesData.getData(), 120, monthSalesData.getLabels(), monthSalesData.getTitle(), 0xcF809f39, "Month", "Number of Sales");
        monthHistograph.setBackgroundColor(0x3FFFFFFF);
        monthHistograph.setVisible(false);
        monthHistograph.setTextColor(0xFFFFFFFF);

        if (dateData == null)
            dateData = queries.dateAmountDiscreteData(listOfIDs, 20);
        dateHistograph = new Histograph(container, CHART_POSITION, CHART_SIZE,
                dateData.getData(), 120, dateData.getLabels(), dateData.getTitle(), 0xcFFF2622, "Date", "Number of Sales");
        dateHistograph.setBackgroundColor(0x3FFFFFFF);
        dateHistograph.setVisible(false);
        dateHistograph.setTextColor(0xFFFFFFFF);

    }

    public void setupPieCharts()
    {
        if (propertyData == null)
            propertyData = queries.propertyTypeDiscreteData(listOfIDs,
                    new String[]{Land.TERRACED, Land.SEMI_DETACHED, Land.DETACHED, Land.FLATS_MAISONETTES, Land.OTHER});
        typePieChart = new PieChart(container, PIE_CHART_POSITION, PIE_CHART_SIZE,
                propertyData.getData(), 225, propertyData.getLabels(), "Type of Property");

        typePieChart.setBackgroundColor(0x3FFFFFFF);
        typePieChart.setVisible(false);
        typePieChart.setTextColor(0xFFFFFFFF);
        typePieChart.setFontSize(12);
        typePieChart.setLabelBackgroundColor(0x3F000000);

        if (typeData == null)
            typeData = queries.conditionDiscreteData(listOfIDs);
        conditionPieChart = new PieChart(container, PIE_CHART_POSITION, PIE_CHART_SIZE,
                typeData.getData(), 200, typeData.getLabels(), "Condition of Property");
        conditionPieChart.setBackgroundColor(0x3FFFFFFF);
        conditionPieChart.setVisible(false);
        conditionPieChart.setTextColor(0xFFFFFFFF);
        conditionPieChart.setFontSize(12);
        conditionPieChart.setLabelBackgroundColor(0x3F000000);
    }

    public void setupLineCharts()
    {
        if (monthSalesData == null)
            monthSalesData = queries.monthSalesDiscreteData(listOfIDs);
        monthLineChart = new LineChart(container, CHART_POSITION, CHART_SIZE,
                monthSalesData.getData(), 120, monthSalesData.getLabels(), monthSalesData.getTitle(),"Month", "Number of Sales");
        monthLineChart.setBackgroundColor(0x3FFFFFFF);
        monthLineChart.setVisible(false);
        monthLineChart.setTextColor(0xFFFFFFFF);
        monthLineChart.setLineColor(0xFFFFFFFF);
        monthLineChart.setPointColor(0);

        if (monthAverageData == null)
            monthAverageData = queries.monthAverageDiscretData(listOfIDs);
        monthAverageLineChart = new LineChart(container, CHART_POSITION, CHART_SIZE,
                monthAverageData.getData(), 120, monthAverageData.getLabels(), monthAverageData.getTitle(), "Month", "Average Price()");
        monthAverageLineChart.setBackgroundColor(0x3FFFFFFF);
        monthAverageLineChart.setVisible(false);
        monthAverageLineChart.setTextColor(0xFFFFFFFF);
        monthAverageLineChart.setLineColor(0xFFFFFFFF);
        monthAverageLineChart.setPointColor(0);

        if (dateData == null)
            dateData = queries.dateAmountDiscreteData(listOfIDs, 10);
        dateLineChart = new LineChart(container, CHART_POSITION, CHART_SIZE,
                dateData.getData(), 120, dateData.getLabels(), dateData.getTitle(),"Date", "Number of Sales");
        dateLineChart.setBackgroundColor(0x3FFFFFFF);
        dateLineChart.setVisible(false);
        dateLineChart.setTextColor(0xFFFFFFFF);
        dateLineChart.setLineColor(0xFFFFFFFF);
        dateLineChart.setPointColor(0);

        if (dateAverageData == null)
            dateAverageData = queries.dateAverageDiscreteData(listOfIDs, 10);
        dateAverageLineChart = new LineChart(container, CHART_POSITION, CHART_SIZE,
                dateAverageData.getData(), 120, dateAverageData.getLabels(), dateAverageData.getTitle(), "Date", "Average Price()");
        dateAverageLineChart.setBackgroundColor(0x3FFFFFFF);
        dateAverageLineChart.setVisible(false);
        dateAverageLineChart.setTextColor(0xFFFFFFFF);
        dateAverageLineChart.setLineColor(0xFFFFFFFF);
        dateAverageLineChart.setPointColor(0);

    }

}
package gui;

import datatypes.UDim2;
import gui.events.Event;
import gui.events.Event.EventOperation;
import gui.primitive.Container;
import gui.primitive.Parent;
import gui.primitive.TextButton;
import processing.event.MouseEvent;

public class Scrollframe extends Container implements Parent{
	private static final int SCROLLBAR_THICKNESS = 10;
	
	protected Container holder;
	protected Container scrollbarHolder;
	protected TextButton scrollbar;
	
	private boolean scrollbarActive = false;
	private float lastMouseY = -1;
	
	public Scrollframe (Parent parent, UDim2 position, UDim2 size) {
		super(parent, position, size);

		this.setClipDescendants(true);
		this.setBackgroundColor(applet.TRANSPARENT);
		this.setBorder(false);
		
		this.holder = new Container (this, new UDim2 (0, 0, 0, 0), new UDim2 (1,-SCROLLBAR_THICKNESS,1,1));
		holder.setBorder(false);

		scrollbarHolder = new Container (this, new UDim2 (1, -SCROLLBAR_THICKNESS, 0, 0), new UDim2 (0, SCROLLBAR_THICKNESS, 1, 0));
		scrollbarHolder.setBorder(false);
		scrollbarHolder.setBackgroundColor(applet.TRANSPARENT);
		
		scrollbar = new TextButton (scrollbarHolder, new UDim2 (1, 0, this.size.absoluteY()/holder.getSize().absoluteY(), 0), "");
		scrollbar.setBackgroundColor(255);
		
		EventOperation beginDrag = () -> {
			lastMouseY = applet.mouseY;
		};
		
		scrollbar.MouseButton1Down.connect(beginDrag);
		applet.registerMethod("mouseEvent",this);
	}
	
	public Scrollframe (Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	public void mouseEvent(MouseEvent event)
	{
		if(event.getAction()==MouseEvent.WHEEL)
		{
			if(mouseInside)
			{
				moveScrollbar(event.getCount()/10f);
			}
		}
	}
	
	@Override
	public void update () {
		super.update();
		if (!applet.mousePressed)
			lastMouseY = -1;
		if (lastMouseY != -1) {
			float alpha = (applet.mouseY - applet.pmouseY)/(size.absoluteY());//lastMouseY;
			moveScrollbar(alpha);
			lastMouseY = applet.mouseY;
		}
		scrollbar.setSize(new UDim2 (1, 0, this.size.absoluteY()/holder.getSize().absoluteY(), 0));
	}
	
	protected void moveScrollbar(float percentage) {
		float newScaleY = scrollbar.getPosition().yScale + percentage;
		newScaleY = newScaleY < 0 ? 0 : newScaleY > (1 - scrollbar.getSize().yScale) ? 1 - scrollbar.getSize().yScale : newScaleY;
		scrollbar.setPosition(new UDim2 (0,0,newScaleY,0));
		newScaleY = -newScaleY*holder.getSize().yScale;
		newScaleY = newScaleY < -holder.getSize().yScale ? -holder.getSize().yScale : newScaleY > 0 ? 0 : newScaleY;
		holder.setPosition(new UDim2(0,0,newScaleY,0));
	}
	
	public void setContentSize (float yScale) {
		holder.setSize(new UDim2 (1, -SCROLLBAR_THICKNESS, yScale, 0));
		holder.setPosition(new UDim2 ());
		scrollbarActive = yScale >= 1f;
		scrollbar.setVisible(scrollbarActive);
	}
	
	public Container getContentHolder () {
		return holder;
	}
	
	public void changeContentBackground (int color) {
		holder.setBackgroundColor(color);
	}
}package gui.input;

import java.util.ArrayList;
import datatypes.UDim2;
import gui.events.Event.EventOperation;
import gui.primitive.Container;
import gui.primitive.Parent;
import gui.primitive.TextButton;

public class DropdownMenu extends TextButton implements Input {

	protected class Option {
		public String text;
		public TextButton button;
		public EventOperation operation;
		
		public Option (String text, TextButton button, EventOperation operation) {
			this.text = text;
			this.button = button;
			this.operation = operation;
		}
	}
	
	protected boolean active = false;
	protected Container clipper;
	protected Container optionsHolder;
		
	protected ArrayList<Option> options = new ArrayList<> ();
	
	public DropdownMenu (Parent parent, UDim2 position, UDim2 size, String text) {
		super(parent, position, size, text);
		clipper = new Container (this, new UDim2 (0, 0, 1, 1), new UDim2 (1, 2, 0, 0));
		clipper.setBorder(false);
		clipper.setBackgroundColor(0x00ffffff);
		clipper.setClipDescendants(true);
		optionsHolder = new Container (clipper, new UDim2(1,0,1,0));
		optionsHolder.setBackgroundColor(0x00ffffff);
		optionsHolder.setBorder(false);
	
		this.MouseButton1Click.connect(() -> {
			if (!tweening) {
				active = !active;
				if (active) {
					clipper.tweenSize(new UDim2 (1, 0, options.size(), 0),0.2f);
				} else {
					clipper.tweenSize(new UDim2(1,0,0,0), 0.2f);
				}
			}
		});
	}
	
	@Override
	public void update () {
		super.update();
		
	}
	
	public DropdownMenu(Parent parent, UDim2 size, String text) {
		this(parent, new UDim2 (), size, text);
	}
	
	public void addOption (String... options) {
		for (String option: options) {
			TextButton button = new TextButton (optionsHolder, new UDim2 (), option);
			button.setDynamicBorder(true);
			button.setBorder(true);
			button.setActiveBorderColor(this.activeBorderColor);
			button.setBackgroundColor(this.backgroundColor);
			button.setBorderColor(this.backgroundColor);
			button.setBorderThickness(this.borderThickness);
			button.setFont(this.font);
			
			EventOperation operation = () -> setText(option);
			button.MouseButton1Click.connect(operation);
			this.options.add(new Option(option, button, operation));
		}
		updateOptionsHolder();
	}
	
	public void updateOptionsHolder () {
		float size = (float) this.options.size();
		for (int i = 0; i < size; i++) {
			TextButton button = this.options.get(i).button;
			button.setSize(new UDim2 (1, 0, 1f/size, 0));
			button.setPosition(new UDim2 (0, 0, ((float) i)/size, 0));
		}
	}
	
	@Override
	public String getValue () {
		return this.text;
	}
}
package gui.input;

public class RadioButtonContainer {

}
package gui.input;

import java.util.ArrayList;
import java.util.HashMap;

import datatypes.UDim2;
import gui.events.Event.EventOperation;
import gui.input.AdvancedDropdown.Option;
import gui.primitive.Container;
import gui.primitive.Parent;
import gui.primitive.TextButton;
import gui.primitive.TextLabel;

public class CheckboxList extends Container {
	protected class Option {
		public String text;
		public Container container;
		public CheckBox box;
		public TextLabel label;
		public Container boxContainer;
		
		public Option (String text, Container container, Container boxContainer, CheckBox box, TextLabel label) {
			this.text = text;
			this.container = container;
			this.boxContainer = boxContainer;
			this.box = box;
			this.label = label;
		}
	}
	
	protected ArrayList<Option> options = new ArrayList<>();
	
	public CheckboxList (Parent parent, UDim2 position, UDim2 size) {
		super(parent, position, size);
		addOption("All");
		CheckBox box = options.get(0).box;
		box.MouseButton1Click.connect(()-> {
			boolean value = box.getValue();
			for (Option option: options) {
				option.box.clicked = value;
			}
		});
	}
	
	public CheckboxList (Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	public void addOption (String ... options) {
		for (String option: options) {
			Container optionContainer = new Container (this, new UDim2 (1, 0, 0, 0));
			optionContainer.setBorder(false);
			optionContainer.setBackgroundColor(applet.TRANSPARENT);
			optionContainer.setClipDescendants(true);
			optionContainer.setBackgroundColor(applet.FOREGROUND_COLOR);
			Container boxContainer = new Container (optionContainer, new UDim2 ());
			boxContainer.setBackgroundColor(0xa0ffffff);
			boxContainer.setBorder(true);
			boxContainer.setBorderThickness(2);
			boxContainer.setDynamicBorder(false);
			CheckBox box = new CheckBox (boxContainer, new UDim2 (), new UDim2 (1, 0, 1, 0), "");
			box.setActiveBackgroundColor(0xd0000000);
			TextLabel label = new TextLabel (optionContainer, new UDim2 (), new UDim2 (), option);
			label.setFont(applet.defaultFont);
			label.setTextSize(applet.NORMAL_TEXT_SIZE);
			label.setTextColor(applet.TEXT_COLOR);
			label.setHorizontalAlign(applet.LEFT);
			
			this.options.add(new Option(option, optionContainer, boxContainer, box, label));
		}
		updateOptionsHolder();
	}
	
	public void updateOptionsHolder () {
		float size = 1 / (float) (this.options.size());
		for (int i = 0; i < options.size(); i++) {
			Option option = this.options.get(i);
			option.container.setSize(new UDim2 (1, 0, size, 0));
			option.container.setPosition(new UDim2 (0, 0, size * i, 0));
			option.boxContainer.setSize(new UDim2 (1, 0, 1, 0));
			float squareSize = option.boxContainer.getSize().absoluteY();
			option.boxContainer.setSize(new UDim2 (0, squareSize, 1, 0));
			option.box.setSize(new UDim2 (0.8f, 0, 0.8f, 0));
			option.box.setPosition(new UDim2 (0.1f, 0, 0.1f, 0));
			option.label.setSize(new UDim2 (1, 0, 1, 0));
			option.label.setPosition(new UDim2 (0, squareSize + 5, 0, 0));
		}
	}
	
	public HashMap<String, Boolean> getAllInputs () {
		HashMap<String, Boolean> inputs = new HashMap<> ();
		
		for (Option option: options) {
			if (!(option.label.getText().contains("All"))) {
				String optionText = option.label.getText();
				Boolean value = option.box.getValue();
				inputs.put(optionText, value);
			}
		}
		
		return inputs;
	}
}package gui.input;

import datatypes.UDim2;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import gui.primitive.TextButton;

public class CheckBox extends TextButton
{
	protected boolean clicked;
	protected int activeBackgroundColor;
	protected int inactiveBackgroundColor;
	
	public CheckBox(Parent parent, UDim2 position, UDim2 size, String text)
	{
		super(parent, position, size, text);
		clicked = false;
		MouseButton1Down.connect(()->clickReaction());
		activeBackgroundColor=0xFFAADAAA;
		inactiveBackgroundColor=getBackgroundColor();
	}
	
	protected void addClick()
	{
		clicked = true;
	}
	
	protected void removeClick()
	{
		clicked = false;
	}
	
	protected void toggleClick()
	{
		if (clicked) {
			clicked = false;
		}
		else {
			clicked = true;
		}
	}
	
	protected void clickReaction()
	{
		toggleClick();
	}
	
	public void setActiveBackgroundColor(int color)
	{
		activeBackgroundColor = color;
	}
	
	public void setInactiveBackgroundColor(int color)
	{
		inactiveBackgroundColor = color;
	}
	
	public void draw(GuiObject self)
	{
		if (clicked)
			setBackgroundColor(activeBackgroundColor);
		else
			setBackgroundColor(inactiveBackgroundColor);
		super.draw(self);
	}
	
	public boolean getValue () {
		return this.clicked; 
	}
	
}
package gui.input;

import datatypes.UDim2;
import gui.events.*;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import gui.primitive.TextButton;
import processing.core.PApplet;
import processing.event.KeyEvent;
import processing.event.MouseEvent;

public class TextBox extends TextButton implements InputListener
{
	int cursor;
	StringBuilder queryString;
	boolean focus;
	String pattern;
	public final Event Output;
	public final Event TextChanged = new Event ();
	public final Event mouseClick;
	protected static final int MIN_HOLD_PERIOD = 20; 		// In milliseconds.
	protected static final int HOLD_PERIOD = 500;
	protected long startTime;
	protected static final int STOPPED = -1;
	protected int currentHoldPeriod;
	
	public TextBox(Parent parent, UDim2 position, UDim2 size,String regex)
	{
		super(parent,position,size,"");
		applet.registerMethod("keyEvent", this);
		applet.registerMethod("mouseEvent",this);
		focus = false;
		cursor = 0;
		queryString = new StringBuilder();
		pattern=regex;
		Output = new Event();
		mouseClick = new Event();
		mouseClick.connect(()->{
		if(mouseInside)
			setFocus();
		else
			removeFocus();
		});
		setHorizontalAlign(PApplet.LEFT);
		setVerticalAlign(PApplet.CENTER);
		startTime=STOPPED;
		currentHoldPeriod = HOLD_PERIOD-MIN_HOLD_PERIOD;
	}
	
	public void keyEvent(KeyEvent event)
	{
		float[] ordinates = getTruePosition();
		if(event.getAction() == KeyEvent.RELEASE)
		{
			startTime=STOPPED;
			currentHoldPeriod = HOLD_PERIOD-MIN_HOLD_PERIOD;
		}
		if(visible && focus && event.getAction() == KeyEvent.PRESS && applet.frame.getNextScreenId() == -1 && !tweening
				&& (ordinates[0]>=0 && ordinates[1]>=0 && ordinates[0]<applet.displayWidth && ordinates[1]<applet.displayHeight))
		{
			if(event.getKey()==PApplet.CODED && event.getKeyCode()>=37 && event.getKeyCode()<=40)
			{
				if(event.getKeyCode()==PApplet.LEFT)
				{
					moveCursorLeft();
				}
				else if(event.getKeyCode()==PApplet.RIGHT)
					moveCursorRight();
			}
			else if(event.getKey()==PApplet.BACKSPACE)
			{
				append(event.getKey());
				startTime=System.currentTimeMillis();
			}
			else if((event.getKey()>=32 && event.getKey()<=126) )
			{
				String key = Character.toString(event.getKey());
				if(key.matches(pattern))
				{
					append(event.getKey());
					startTime=System.currentTimeMillis();
				}

			}
			else
			{
				if(event.getKey()==PApplet.RETURN || event.getKey()==PApplet.ENTER)
				{
					removeFocus();
					Output.trigger();
				}
			}
		}
	}
	
	public void mouseEvent(MouseEvent event)
	{
		if(event.getAction()==MouseEvent.CLICK || event.getAction()==MouseEvent.PRESS 
				|| event.getAction()==MouseEvent.RELEASE)
		{
			mouseClick.trigger();
		}
	}
	
	public void setFocus()
	{
		focus = true;
		clearString();
		setText("");
	}
	
	public void removeFocus()
	{
		focus=false;
	}
	
	public void moveCursorLeft()
	{
		if(cursor>0)
			cursor--;
	}
	
	public void moveCursorRight()
	{
		if(cursor<queryString.length())
			cursor++;
	}
	
	public void append(char keyPressed)
	{
		if(keyPressed==PApplet.BACKSPACE)
		{
			if(cursor!=0)
				cursor--;
			if(queryString.toString()!="" && queryString.length()!=0)
				queryString = queryString.deleteCharAt(cursor);
		}
		else
		{
			queryString.insert(cursor, keyPressed);	
			cursor++;
		}
		setText(queryString.toString());
	}
	
	public void displayCursor()
	{
		float displayDistance=0;
		float lineNumber = 0;
		float textHeight = applet.textAscent()+applet.textDescent();
		if(cursor>0)
		{
			displayDistance = applet.textWidth(queryString.substring(0,cursor))%size.absoluteX();
			lineNumber = (int)(applet.textWidth(queryString.substring(0,cursor))/size.absoluteX());
		}
		
		if((textHeight+2)*(lineNumber+1)<size.absoluteY())
		{
			float[] ordinates = getTruePosition();
			applet.stroke(applet.TEXT_COLOR);
			applet.line(ordinates[0]+.25f+displayDistance+lineNumber*2,
					ordinates[1]+(textHeight+2)*lineNumber + ((size.absoluteY()/2)-textHeight/2),
					ordinates[0]+.25f+displayDistance+lineNumber*2,
					ordinates[1]+(textHeight+2)*(lineNumber+1)+((size.absoluteY()/2)-textHeight/2));
		}
	}
	
	
	public void clearString()
	{
		queryString = new StringBuilder();
		cursor = 0;
		setText("");
	}
	
	public String getString(int index)
	{
		return queryString.substring(index);
	}
	
	public String getString(int index,int lastindex)
	{
		return queryString.substring(index,lastindex);
	}
	
	@Override
	public void draw(GuiObject self)
	{
		if(startTime!=STOPPED)
		{
			if(System.currentTimeMillis()-startTime>MIN_HOLD_PERIOD+currentHoldPeriod)
			{
				startTime=System.currentTimeMillis();
				append(applet.key);
				currentHoldPeriod /= 5;
			}
		}
		super.draw(self);
		if(focus)
			displayCursor();
	}
	
	@Override
	public void setText (String text) {
		try {
			TextChanged.trigger();
		} catch (NullPointerException e) {
			System.out.println();
		}
		super.setText(text);
	}
}
package gui.input;

import processing.event.KeyEvent;
import processing.event.MouseEvent;

public interface InputListener 
{
	public void keyEvent(KeyEvent event);
	public void mouseEvent(MouseEvent event);
}
package gui.input;

public interface Input {
	public String getValue ();
}package gui.input;

public class RadioButton {

}
package gui.input;

import java.util.ArrayList;

import datatypes.UDim2;
import gui.Scrollframe;
import gui.events.Event;
import gui.events.Event.EventOperation;
import gui.input.DropdownMenu.Option;
import gui.primitive.Container;
import gui.primitive.Parent;
import gui.primitive.TextButton;

public class AdvancedDropdown extends Container {
	protected TextBox input;
	protected Scrollframe scrollframe;
	
	protected final long TEXT_CHANGE_INTERVAL = 100;
	protected long lastTextChange = -1;
	protected boolean updatedList = false;
	protected boolean scrollframeActive = true;
	
	protected ArrayList<Option> options = new ArrayList<>();
	protected ArrayList<Option> activeOptions = new ArrayList<>();
	
	public final Event Output = new Event ();
	public int test = 0;
	protected class Option {
		public String text;
		public TextButton button;
		public EventOperation operation;
		
		public Option (String text, TextButton button, EventOperation operation) {
			this.text = text;
			this.button = button;
			this.operation = operation;
		}
	}
	
	public AdvancedDropdown (Parent parent, UDim2 position, UDim2 size) {
		super(parent,position,size);
		this.setBackgroundColor(applet.TRANSPARENT);
		this.setBorder(false);
		
		input = new TextBox (this, new UDim2 (), new UDim2 (1, 0, (1f/6f), 0), ".");
		input.setBackgroundColor(applet.FOREGROUND_COLOR);
		input.setTextSize((int) (input.getSize().absoluteY()*0.6f));
		
		input.TextChanged.connect(()->{
			lastTextChange = System.currentTimeMillis();
			updatedList = false;
			toggleScrollframe();
		});
		
		scrollframe = new Scrollframe (this, new UDim2 (0, 0, (1f/6f), 0), new UDim2 (1, 0, (5f/6f), 0));
		scrollframe.changeContentBackground(applet.POPUP_COLOR);
		scrollframe.setZIndex(0);
		scrollframe.getContentHolder().setZIndex(0);
		toggleScrollframe();
		
		input.Output.connect(()->{
			String output = "";
			ArrayList<Option> list = activeOptions.size() != 0 ? activeOptions : options;
			for (int i = 0; i < list.size() && output.equals(""); i++) {
				Option option = list.get(i);
				if (option.button.getText().toLowerCase().contains(input.getText().toLowerCase())) {
					output = option.button.getText();
				}
			}
			
			if (!output.equals("")) {
				input.setText(output);
				this.Output.trigger();
			}
		});
	}
	
	public AdvancedDropdown (Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	@Override
	public void update () {
		super.update();
		if (lastTextChange != -1 && !input.getText().equals("") && input.focus)
			if (System.currentTimeMillis() - lastTextChange > TEXT_CHANGE_INTERVAL && !updatedList) {
				updatedList = true;
				
				activeOptions.clear();
				for (Option option: options) {
					if (option.text.toLowerCase().contains(input.getText().toLowerCase())) {
						activeOptions.add(option);
						option.button.setVisible(true);
					} else {
						option.button.setVisible(false);
					}
				}
				toggleScrollframe();
			}
	}
	
	public void toggleScrollframe () {
		if (scrollframeActive != updatedList) {
			updateOptionsHolder();
			UDim2 initialSize = updatedList ? new UDim2 (1, 0, 0, 0) : new UDim2 (1, 0, 5f/6f, 0);
			UDim2 finalSize = updatedList ? new UDim2 (1, 0, 5f/6f, 0) : new UDim2 (1, 0, 0, 0);
			scrollframe.tweenSize(initialSize,  finalSize, 0.1f);
			scrollframeActive = updatedList;
		}
		
		if (!scrollframeActive) {
			for (Option option: options) {
				option.button.setVisible(false);
			}
		}
	}
	
	public void addOption (String... options) {
		for (String option: options) {
			TextButton button = new TextButton (scrollframe.getContentHolder(), new UDim2 (), option);
			button.setDynamicBorder(true);
			button.setBorder(true);
			button.setActiveBorderColor(this.activeBorderColor);
			button.setBackgroundColor(applet.TRANSPARENT);
			button.setBorderColor(this.backgroundColor);
			button.setBorderThickness(this.borderThickness);
			button.setFont(applet.defaultFont);
			button.setTextSize(input.getTextSize());
			button.setVisible(false);
			
			EventOperation operation = () -> {
				input.clearString();
				input.setText(option);
				input.removeFocus();
				this.Output.trigger();
			};
			button.MouseButton1Click.connect(operation);
			this.options.add(new Option(option, button, operation));
		}
		updateOptionsHolder();
	}
	
	public void updateOptionsHolder () {
		float size = (float) this.activeOptions.size();
		scrollframe.setContentSize(size/5f);
		for (int i = 0; i < size; i++) {
			TextButton button = this.activeOptions.get(i).button;
			float buttonSize = 0.2f * (this.size.absoluteY() * (5f/6f));
			button.setSize(new UDim2 (1, -1, 0, buttonSize));
			button.setPosition(new UDim2 (0, 0, 0, i * buttonSize));
		}
	}
	
	public String getOutput () {
		return input.getText();
	}
	
	public String[] getAllOptions () {
		ArrayList<String> allOptions = new ArrayList<>();
		for (Option option: options) {
			allOptions.add(option.text);
		}
		return allOptions.toArray(new String[allOptions.size()]);
	}
}
package gui.input;

import datatypes.UDim2;
import gui.primitive.GuiObject;
import gui.primitive.Parent;
import gui.primitive.TextButton;

public class Slider extends TextButton{
	protected static final int SLIDER_SIZE = 20;
	protected static final int SLIDER_OUTER_COLOUR = 0xFFBBBBBB;
	protected static final int SLIDER_INNER_COLOUR = 0xFF666666;
	protected static final int SLIDER_BAR_COLOUR = 0xEE6F6F6F;
	private float minSliderPosition;
	private float maxSliderPosition;
	protected final int MIN_VALUE;
	protected final int MAX_VALUE;
	private float sliderPosition;
	private int sliderValue;
	protected String label;
	protected boolean selected;
	protected float[] coordinates;
	private float graduation;
	
	public Slider(Parent parent, UDim2 position, UDim2 size, int minValue, int maxValue, String label)
	{
		super(parent, position, size, label);
		coordinates = getTruePosition();
		minSliderPosition = coordinates[0];
		maxSliderPosition = minSliderPosition + size.absoluteX();
		this.MIN_VALUE = minValue;
		this.MAX_VALUE = maxValue;
		this.label = label;
		sliderPosition = minSliderPosition;
		sliderValue = MIN_VALUE;
		graduation = (maxSliderPosition - minSliderPosition)/(float)(MAX_VALUE-MIN_VALUE);
	}
	
	private void moveSlider()
	{
		updatePosition();
		if (!applet.mousePressed)
			selected = false;
		
		if (selected || clickedOn())
			sliderPosition = applet.mouseX;
		
		if (sliderPosition > maxSliderPosition)
			sliderPosition = maxSliderPosition;
		else if (sliderPosition < minSliderPosition)
			sliderPosition = minSliderPosition;
		
		sliderValue = (int)Math.round(((sliderPosition - minSliderPosition)/graduation) + MIN_VALUE);
	}
	
	private void updatePosition()
	{
		float lastMinSliderPosition = minSliderPosition;
		coordinates = getTruePosition();
		minSliderPosition = coordinates[0];
		maxSliderPosition = minSliderPosition + size.absoluteX();
		sliderPosition+= minSliderPosition - lastMinSliderPosition;
		
		graduation = (maxSliderPosition - minSliderPosition)/(float)(MAX_VALUE-MIN_VALUE);
	}
	
	public boolean clickedOn()
	{
		selected = mouseInside && applet.mousePressed;
		return selected;
	}
	
	public int getSliderValue()
	{
		return sliderValue;
	}
	
	public void setSliderValue(int newValue)
	{
		if (newValue >= MIN_VALUE && newValue <= MAX_VALUE)
		{
			sliderValue = newValue;
			sliderPosition = (graduation * sliderValue) + minSliderPosition;
		}
	}
	
	public void draw(GuiObject self)
	{
		moveSlider();
		applet.noStroke();
		applet.fill(SLIDER_BAR_COLOUR);
		applet.rect(minSliderPosition, coordinates[1], size.absoluteX(), size.absoluteY(), 10, 10, 10, 10);
		
		applet.fill(SLIDER_OUTER_COLOUR);
		applet.ellipse(sliderPosition, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE, SLIDER_SIZE);
		applet.fill(SLIDER_INNER_COLOUR);
		applet.ellipse(sliderPosition, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE/2, SLIDER_SIZE/2);
		
		//applet.fill(0xFF111111);
		//applet.text(getSliderValue(), coordinates[0] - 50, coordinates[1] + size.absoluteY()/2);
		//applet.text(label, coordinates[0]+ size.absoluteX()/2, coordinates[1] - size.absoluteY());
	}
}
package gui.input;

import java.util.ArrayList;
import java.util.HashMap;

import datatypes.UDim2;
import gui.Scrollframe;
import gui.primitive.Parent;
import gui.primitive.TextButton;

public class InputList extends Scrollframe {
	protected static final int NUMBER_OF_INPUTS_RENDERED = 6;
	
	protected class Input {
		public TextButton button;
		public String input;
		
		public Input (TextButton button, String input) {
			this.button = button;
			this.input = input;
		}
	}
	
	protected HashMap<Input, Boolean> inputs = new HashMap<>();
	protected ArrayList<Input> removalQueue = new ArrayList<>();
	
	public InputList (Parent parent, UDim2 position, UDim2 size) {
		super(parent, position, size);
		updateContainer();
	}
	
	public InputList(Parent parent, UDim2 size) {
		this(parent, new UDim2 (), size);
	}
	
	@Override
	public void update () {
		for (Input input: removalQueue) {
			inputs.remove(input);
			holder.removeChild(input.button);
			updateContainer();
		}
		super.update();
	}
	public void addInput(String input) {
		TextButton button = new TextButton (holder, new UDim2 (), input);
		button.setFont(applet.defaultFont);
		button.setBorder(true);
		button.setBorderColor(applet.TRANSPARENT);
		Input object = new Input (button, input);
		inputs.put(object, true);
		button.MouseButton1Click.connect(()->removalQueue.add(object));
		updateContainer();
	}
	
	public void updateContainer () {
		int numberOfInputs = inputs.size();
		setContentSize((float)numberOfInputs/(float)NUMBER_OF_INPUTS_RENDERED);
		float buttonSize = 1f/numberOfInputs;
		int i = 0;
		for (Input input: inputs.keySet()) {
			input.button.setSize(new UDim2 (1, 0, buttonSize,0));
			input.button.setPosition(new UDim2 (0, 0, buttonSize * i, 0));
			i++;
		}
	}
	
	public String[] getAllInputs() {
		ArrayList<String> allInputs = new ArrayList<>();
		for (Input input: inputs.keySet()) {
			allInputs.add(input.input);
		}
		return allInputs.toArray(new String[allInputs.size()]);
	}
	
	public void clearInputs () {
		inputs = new HashMap<Input, Boolean> ();
		holder.clearAllChildren();
	}
}package gui.input;

import datatypes.UDim2;
import gui.events.Event;
import gui.primitive.GuiObject;
import gui.primitive.Parent;

public class DoubleSlider extends Slider {
	
	private float minSlider1Position;
	private float maxSlider1Position;
	private float minSlider2Position;
	private float maxSlider2Position;
	private float slider1Position;
	private float slider2Position;
	private boolean slider1Selected;
	private boolean slider2Selected;
	private float graduation;
	private int slider1Value;
	private int slider2Value;
	
	public final Event Slider1Changed = new Event ();
	public final Event Slider2Change = new Event();
	
	public DoubleSlider(Parent parent, UDim2 position, UDim2 size, int minValue, int maxValue, String label)
	{
		super(parent, position, size, minValue, maxValue, label);
		minSlider1Position = coordinates[0];
		slider1Position = minSlider1Position;
		slider2Position = minSlider1Position + size.absoluteX();
		
		maxSlider1Position = slider2Position;
		minSlider2Position = slider1Position;
		maxSlider2Position = minSlider1Position + size.absoluteX();
		slider1Value = MIN_VALUE;
		slider2Value = MAX_VALUE;
		
		graduation = (maxSlider2Position - minSlider1Position)/(float)(MAX_VALUE-MIN_VALUE);
	}
	
	private void updatePosition()
	{
		float lastMinSlider1Position = minSlider1Position;
		coordinates = getTruePosition();
		minSlider1Position = coordinates[0];
		slider1Position+= minSlider1Position - lastMinSlider1Position;
		slider2Position+= minSlider1Position - lastMinSlider1Position;
		
		maxSlider1Position = slider2Position;
		minSlider2Position = slider1Position;
		maxSlider2Position = minSlider1Position + size.absoluteX();
		
		graduation = (maxSlider2Position - minSlider1Position)/(float)(MAX_VALUE-MIN_VALUE);
	}
	
	private void moveSliders()
	{
		updatePosition();
		if (!applet.mousePressed)
		{
			slider1Selected = false;
			slider2Selected = false;
		}
		
		if (!slider2Selected && (slider1Selected || slider1ClickedOn())) {
			slider1Position = applet.mouseX;
			Slider1Changed.trigger();
		}
		if (!slider1Selected && (slider2Selected || slider2ClickedOn())) {
			slider2Position = applet.mouseX;
			Slider2Change.trigger();
		}
		
		if (slider1Position > maxSlider1Position)
			slider1Position = maxSlider1Position;
		else if (slider1Position < minSlider1Position)
			slider1Position = minSlider1Position;
		
		if (slider2Position > maxSlider2Position)
			slider2Position = maxSlider2Position;
		else if (slider2Position < minSlider2Position)
			slider2Position = minSlider2Position;
		
		slider1Value = (int)Math.round(((slider1Position - minSlider1Position)/graduation) + MIN_VALUE);
		slider2Value = (int)Math.round(((slider2Position - minSlider1Position)/graduation) + MIN_VALUE);
	}
	
	private boolean slider1ClickedOn()
	{
		boolean mouseInside = Math.sqrt(Math.pow(applet.mouseX - slider1Position, 2) 
				+ Math.pow(applet.mouseY - coordinates[1] + size.absoluteY()/2, 2)) < 15;
		slider1Selected = mouseInside && applet.mousePressed && applet.mouseX < maxSlider1Position;
		return slider1Selected;
	}
	
	private boolean slider2ClickedOn()
	{
		boolean mouseInside = Math.sqrt(Math.pow(applet.mouseX - slider2Position, 2) 
				+ Math.pow(applet.mouseY - coordinates[1] + size.absoluteY()/2, 2)) < 15;
		slider2Selected = mouseInside && applet.mousePressed && applet.mouseX > minSlider2Position;
		return slider2Selected;
	}
	
	public int[] getSliderValues()
	{
		return new int[] {slider1Value, slider2Value};
	}
	
	public void setSlider1Value(int newValue)
	{
		slider1Value = newValue;
		if (slider1Value > MAX_VALUE)
			slider1Value = MAX_VALUE;
		else if (slider1Value < MIN_VALUE)
			slider1Value = MIN_VALUE;
		slider1Position = (graduation * newValue) + minSlider1Position;
	}
	
	public void setSlider2Value(int newValue)
	{
		slider2Value = newValue;
		if (slider2Value > MAX_VALUE)
			slider2Value = MAX_VALUE;
		else if (slider2Value < MIN_VALUE)
			slider2Value = MIN_VALUE;
		slider2Position = (graduation * newValue) + minSlider1Position;
	}
	
	public void setSliderValue(int newValue){}
	
	public void draw(GuiObject self)
	{
		moveSliders();
		applet.noStroke();
		applet.fill(SLIDER_BAR_COLOUR);
		applet.rect(minSlider1Position, coordinates[1], size.absoluteX(), size.absoluteY(), 10, 10, 10, 10);
		
		applet.fill(SLIDER_OUTER_COLOUR);
		applet.ellipse(slider1Position, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE, SLIDER_SIZE);
		applet.fill(SLIDER_INNER_COLOUR);
		applet.ellipse(slider1Position, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE/2, SLIDER_SIZE/2);
		applet.fill(SLIDER_OUTER_COLOUR);
		applet.ellipse(slider2Position, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE, SLIDER_SIZE);
		applet.fill(SLIDER_INNER_COLOUR);
		applet.ellipse(slider2Position, coordinates[1] + size.absoluteY()/2, SLIDER_SIZE/2, SLIDER_SIZE/2);
		
		//applet.fill(0xFF111111);
		//applet.text(getSliderValues()[0], coordinates[0] - 50, coordinates[1] + size.absoluteY()/2);
		//applet.text(getSliderValues()[1], coordinates[0] + size.absoluteX() + 50, coordinates[1] + size.absoluteY()/2);
		//applet.text(label, coordinates[0]+ size.absoluteX()/2, coordinates[1] - size.absoluteY());
	}
}
package datatypes;

// UDim2 stands for Universal Dimension x2.
// It is a standard for 2D coordinates that allows finer control of its elements.

public class UDim2 {
	public final float xScale, xOffset, yScale, yOffset;
	private float[] scale = {(float) middleware.Main.SCREEN[0], (float) middleware.Main.SCREEN[1]};
	
	public UDim2 (float xScale, float xOffset, float yScale, float yOffset) {
		this.xScale  = xScale;
		this.xOffset = xOffset;
		this.yScale  = yScale;
		this.yOffset = yOffset;
	}
	
	public UDim2 (float xScale, int xOffset, float yScale, int yOffset) {
		this(xScale, (float) xOffset, yScale, (float) yOffset);
	}
	
	public UDim2 (float xOffset, float yOffset) {
		this(0, xOffset, 0, yOffset);
	}
	
	public UDim2 (int xOffset, int yOffset) {
		this(0, (float) xOffset, 0, (float) yOffset);
	}
	
	public UDim2 () {
		this(0, 0, 0, 0);
	}
	
	public void setScale (float[] scale) {
		this.scale = scale;
	}
	
	public float absoluteX () {
		return xScale * scale[0] + xOffset;
	}
	
	public float absoluteY () {
		return yScale * scale[1] + yOffset;
	}
	
	public UDim2 add (UDim2 dim) {
		return new UDim2(this.xScale + dim.xScale, this.xOffset + dim.xOffset, this.yScale + dim.yScale, this.yOffset + dim.yOffset);
	}
	
	public UDim2 sub (UDim2 dim) {
		return new UDim2(this.xScale - dim.xScale, this.xOffset - dim.xOffset, this.yScale - dim.yScale, this.yOffset - dim.yOffset);
	}
	
	public UDim2 lerp (UDim2 goal, float alpha) {
		UDim2 delta = goal.sub(this);
		return new UDim2 (this.xScale + delta.xScale * alpha, this.xOffset + delta.xOffset * alpha,
									 this.yScale + delta.yScale * alpha, this.yOffset + delta.yOffset * alpha);
	}
	
	public float[] toFloatArray () {
		float[] array = new float[2];
		array[0] = absoluteX();
		array[1] = absoluteY();
		return array;
	}
	
	@Override
	public String toString () {
		return "X{" + xScale + ", " + xOffset + "} Y{" + yScale + ", " + yOffset + "}";
	}
}package middleware;

import processing.core.PApplet;
import processing.core.PFont;
import datatypes.UDim2;
import gui.events.Event.EventOperation;
import gui.input.*;
import gui.map.Map;
import gui.primitive.*;
import database.*;
import java.util.ArrayList;
import java.util.HashMap;

public class Main extends PApplet {
	public static final int[] SCREEN = {1920, 1080};
	
	public final Frame frame = new Frame (this);
	
	public static final String ANY = "Any";
	
	public PFont defaultFont;
	public PFont boldFont;
	public final int NORMAL_TEXT_SIZE = 20;
	public final int TITLE_TEXT_SIZE  = 36;
	public final int TEXT_COLOR		  = 0xffffffff;
	public final int BACKGROUND_COLOR = 0xa0000000;
	public final int FOREGROUND_COLOR = 0x80808080;
	public final int TRANSPARENT	  = 0x00ffffff;
	public final int POPUP_COLOR	  = 0xe0808080;
	
	public static final int MIN = 50000;
	public static final int MAX = 2500000;
	
	protected Map map;
	public Queries queries = new Queries(new DBConnection());
	protected ArrayList<Integer> allIDs = queries.getAllIDs();
	
	public static void main(String[] args) {
		PApplet.main("middleware.Main");
	}

	public void settings () {
		fullScreen();
		size(SCREEN[0], SCREEN[1], P2D);
	}
	
	public void setup () {
		defaultFont = loadFont("gui/Fonts/Calibri-100.vlw");
		boldFont = loadFont("gui/Fonts/Calibri-Bold-100.vlw");
		imageMode(CORNERS);
		frameRate(60);
		
		// Creating the background screen
		Screen backgroundScreen = frame.addScreen(new Screen (this));
		frame.setBackgroundScreen(backgroundScreen);
		ArrayList<Integer> initialQuery = queries.filterPriceRange(100000, Integer.MAX_VALUE);
		map = new Map (backgroundScreen, new UDim2 (), new UDim2 (1, 0, 1, 0), queries, initialQuery);
		Container leftTrigger = new Container (backgroundScreen, new UDim2 (0.15f, 0, 1, 0));
		leftTrigger.setBorder(false);
		leftTrigger.setBackgroundColor(TRANSPARENT);
		
		// Creating the search property sale screen
		Screen userQueryScreen = frame.addScreen(new Screen(this));
		Container userQueryContainer = new Container (userQueryScreen, new UDim2 (0.5f, 0, 1, 0));
		UDim2[] userQueryContainerPositions = {
				new UDim2 (0, -(userQueryContainer.getSize().absoluteX()), 0, 0),
				new UDim2 ()
		};
		userQueryContainer.setPosition(userQueryContainerPositions[0]);
		userQueryContainer.setBorder(false);
		userQueryContainer.setBackgroundColor(BACKGROUND_COLOR);
		userQueryContainer.setClipDescendants(true);
		
		EventOperation toggleUserQueryScreen = () -> {
			boolean userQueryScreenActive = frame.getCurrentScreen() == userQueryScreen;
			int id = userQueryScreenActive ? backgroundScreen.ID : userQueryScreen.ID;
			int p = userQueryScreenActive ? 1 : 0;
			float duration = 0.2f;
			
			frame.setCurrentScreen(id);
			userQueryContainer.tweenPosition(userQueryContainerPositions[p], userQueryContainerPositions[1-p], duration);
		};
		
		leftTrigger.MouseMove.connect(toggleUserQueryScreen);
		userQueryContainer.MouseLeave.connect(toggleUserQueryScreen);
		
		float posY = 0;
		float size = 0.1f;
		TextLabel userQueryScreenTitle = new TextLabel (userQueryContainer, new UDim2 (1, 0, size, 0), "Search Property Sales");
		userQueryScreenTitle.setFont(boldFont);
		userQueryScreenTitle.setTextSize(TITLE_TEXT_SIZE);
	
		final float offset = 0.015f;
		posY += size;
		size = 0.075f;
		Container addressSearchContainer = new Container (userQueryContainer, new UDim2 (0.1f, 0, 0.1f, 0), new UDim2 (0.8f, 0, 0.075f, 0));
		addressSearchContainer.setBorder(false);
		addressSearchContainer.setBackgroundColor(TRANSPARENT);
		addressSearchContainer.setZIndex(0);
		TextLabel addressSearchLabel = new TextLabel (addressSearchContainer, new UDim2 (1, 0, 0.5f, 0), "Search by address");
		addressSearchLabel.setHorizontalAlign(LEFT);
		addressSearchLabel.setFont(boldFont);
		addressSearchLabel.setTextSize(NORMAL_TEXT_SIZE);
		AdvancedDropdown addressSearch = new AdvancedDropdown (addressSearchContainer, new UDim2 (0, 0, 0.5f, 0), new UDim2 (1, 0, 3f, 0));
		addressSearch.addOption(queries.getRandomAddresses(100));
		addressSearch.Output.connect(()->{
			String output = addressSearch.getOutput();
			map.updateMap(queries.filterByAddress(allIDs, output));
		});
		
		posY += size + offset;
		size = 0;
		Container horizontalLine = new Container (userQueryContainer, new UDim2 (0, 0, posY, 0), new UDim2 (1, 0, size, 1));
		horizontalLine.setBorder(false);
		
		posY += size + offset;
		size = 0.2f;
		Container countySearchContainer = new Container (userQueryContainer, new UDim2 (0.1f, 0, posY, 0), new UDim2 (0.8f, 0, size, 0));
		countySearchContainer.setBackgroundColor(TRANSPARENT);
		countySearchContainer.setBorder(false);
		TextLabel countySearchLabel = new TextLabel (countySearchContainer, new UDim2 (1, 0, 0.2f, 0), "Search by County");
		countySearchLabel.setFont(boldFont);
		countySearchLabel.setTextSize(NORMAL_TEXT_SIZE);
		InputList currentSelection = new InputList (countySearchContainer, new UDim2 (0.53125f, 0, 0.2f, 0), new UDim2 (0.46785f, 0, 0.8f, 0));
		currentSelection.setBorder(false);
		currentSelection.changeContentBackground(FOREGROUND_COLOR);
		AdvancedDropdown countySelect = new AdvancedDropdown (countySearchContainer, new UDim2 (0, 0, 0.2f, 0), new UDim2 (0.46785f, 0, 0.8f, 0));
		countySelect.addOption(queries.getAllCounties());
		countySelect.addOption("ALL");
		countySelect.Output.connect(()->{
			if (countySelect.getOutput().equals("ALL")) {
				for (String output: countySelect.getAllOptions()) {
					if (!output.equals("ALL") && !output.equals("B") && !output.equals("")) {
						currentSelection.addInput(output);
					}
				}
			} else
				currentSelection.addInput(countySelect.getOutput());
		});
		
		posY += size + offset;
		size = 0.1f;
		Container priceSearchContainer = new Container (userQueryContainer, new UDim2 (0.1f, 0, posY, 0), new UDim2 (0.8f, 0, size, 0));
		priceSearchContainer.setBackgroundColor(TRANSPARENT);
		priceSearchContainer.setBorder(false);
		TextLabel priceSearchLabel = new TextLabel (priceSearchContainer, new UDim2 (1, 0, 0.5f, 0), "Search by Price");
		priceSearchLabel.setFont(boldFont);
		priceSearchLabel.setTextSize(NORMAL_TEXT_SIZE);
		DoubleSlider priceSelection = new DoubleSlider (priceSearchContainer, new UDim2 (0, 0, 0.5f, 0), new UDim2 (1, 0, 0.1f, 0), MIN, MAX, "Price");
		TextLabel minPriceLabel = new TextLabel (priceSearchContainer, new UDim2 (0.25f, 0, 0.5f, 0), MIN + "");
		minPriceLabel.setHorizontalAlign(LEFT);
		TextLabel maxPriceLabel = new TextLabel (priceSearchContainer, new UDim2 (0.75f, 0, 0, 0), new UDim2 (0.25f, 0, 0.5f, 0), MAX + "");
		maxPriceLabel.setHorizontalAlign(RIGHT);
		TextBox minPrice = new TextBox (priceSearchContainer, new UDim2 (0, 0, 0.66f, 0), new UDim2 (0.46785f, 0, 0.35f, 0), "\\d");
		minPrice.setBackgroundColor(FOREGROUND_COLOR);
		TextBox maxPrice = new TextBox (priceSearchContainer, new UDim2 (0.53125f, 0, 0.66f, 0), new UDim2 (0.46785f, 0, 0.35f, 0), "\\d");
		maxPrice.setBackgroundColor(FOREGROUND_COLOR);
		new Container (priceSearchContainer, new UDim2 (0.48370f, 0, 0.75f, 0), new UDim2 (0.03170f, 0, 0.1f, 0));
		minPrice.Output.connect(() -> {
			if (!minPrice.getText().equals(""))
				priceSelection.setSlider1Value(Integer.parseInt(minPrice.getText()));
		});
		maxPrice.Output.connect(() -> {
			if (!maxPrice.getText().equals(""))
				priceSelection.setSlider2Value(Integer.parseInt(maxPrice.getText()));
		});
		priceSelection.Slider1Changed.connect(() -> {
			int[] prices = priceSelection.getSliderValues();
			minPrice.setText(prices[0]+"");
		});
		priceSelection.Slider2Change.connect(() -> {
			int[] prices = priceSelection.getSliderValues();
			maxPrice.setText(prices[1]+"");
		}); 
		
		posY += size + offset;
		size = 0.075f;
		Container dateSearchContainer = new Container (userQueryContainer, new UDim2 (0.1f, 0, posY, 0), new UDim2 (0.8f, 0, size, 0));
		dateSearchContainer.setBackgroundColor(TRANSPARENT);
		dateSearchContainer.setBorder(false);
		TextLabel dateInputLabel = new TextLabel (dateSearchContainer, new UDim2 (1, 0, 0.5f, 0), "Search by Date");
		dateInputLabel.setFont(boldFont);
		dateInputLabel.setTextSize(NORMAL_TEXT_SIZE);
		TextButton earliestDateInput = new TextBox (dateSearchContainer, new UDim2 (0, 0, 0.5f, 0), new UDim2 (0.46785f, 0, 0.5f, 0), "[\\d/]");
		earliestDateInput.setBackgroundColor(FOREGROUND_COLOR);
		earliestDateInput.setTextSize(NORMAL_TEXT_SIZE);
		earliestDateInput.setFont(defaultFont);
		new Container (dateSearchContainer, new UDim2 (0.48370f, 0, 0.7f, 0), new UDim2 (0.03170f, 0, 0.1f, 0));
		TextButton latestDateInput = new TextBox (dateSearchContainer, new UDim2 (0.53125f, 0, 0.5f, 0), new UDim2 (0.46785f, 0, 0.5f, 0), "[\\d/]");
		latestDateInput.setBackgroundColor(FOREGROUND_COLOR);
		latestDateInput.setTextSize(NORMAL_TEXT_SIZE);
		latestDateInput.setFont(defaultFont);
		
		posY += size + offset;
		CheckboxList propertySearchContainer = new CheckboxList (userQueryContainer, new UDim2 (0.1f, 0, posY, 0), new UDim2 (0.375f, 0, 0.325f, 0));
		propertySearchContainer.setBorder(false);
		propertySearchContainer.setBackgroundColor(TRANSPARENT);
		String[] types = {Land.DETACHED, Land.SEMI_DETACHED, Land.TERRACED, Land.FLATS_MAISONETTES, Land.OTHER};
		for (String type: types) {
			propertySearchContainer.addOption(type);
		}
		
		CheckboxList conditionSearchContainer = new CheckboxList (userQueryContainer, new UDim2 (0.525f, 0, posY, 0), new UDim2 (0.375f, 0, 0.162f, 0));
		conditionSearchContainer.setBorder(false);
		conditionSearchContainer.setBackgroundColor(TRANSPARENT);
		for (String condition: new String[] {Land.ESTABLISHED, Land.NEWLY_BUILT}) {
			conditionSearchContainer.addOption(condition);
		}
		
		TextButton searchButton = new TextButton (userQueryContainer, new UDim2 (0.525f, 0, 0.9f, 0), new UDim2 (0.375f, 0, 0.05f, 0), "Search");
		searchButton.setTextSize(TITLE_TEXT_SIZE);
		searchButton.setFont(boldFont);
		searchButton.setBackgroundColor(FOREGROUND_COLOR);
		searchButton.MouseButton1Click.connect(()->{
			HashMap<String, Boolean> typeFilter = propertySearchContainer.getAllInputs();
			ArrayList<String> toFilterTypes = new ArrayList<>();
			for (String key: typeFilter.keySet()) {
				if (typeFilter.get(key)) {
					toFilterTypes.add(key);
				}
			}
			ArrayList<Integer> filtered = queries.filterPropertyType(toFilterTypes.toArray(new String[toFilterTypes.size()]));
			
			HashMap<String, Boolean> conditionFilter = conditionSearchContainer.getAllInputs();
			ArrayList<String> toFilterConditions = new ArrayList<>();
			for (String key: conditionFilter.keySet()) {
				if (conditionFilter.get(key)) {
					toFilterConditions.add(key);
				}
			}
			filtered = queries.filterCondition(filtered, toFilterConditions.toArray(new String[toFilterConditions.size()]));
			
			filtered = queries.filterByCounty(filtered, currentSelection.getAllInputs());
			
			int[] priceRange = priceSelection.getSliderValues();
			filtered = queries.filterPriceRange(filtered, priceRange[0], priceRange[1]);
			
			String earlyDate = queries.isValidDate(earliestDateInput.getText()) ? earliestDateInput.getText() : "01/01/1990";
			String laterDate = queries.isValidDate(latestDateInput.getText()) ? latestDateInput.getText() : "31/12/2022";
			filtered = queries.filterDate(filtered, earlyDate, laterDate);
			
			map.updateMap(filtered);
			currentSelection.clearInputs();
		});
	}
	
	public void draw () {
		background(200);
		frame.draw();
	}
}
package middleware;

import database.DBConnection;
import database.Queries;
import datatypes.UDim2;
import gui.map.Map;
import gui.primitive.Screen;

import java.util.ArrayList;

public class MapTest extends Screen
{
	public MapTest(Main applet)
	{
		super(applet);
		DBConnection dbConnection = new DBConnection();
		Queries queries = new Queries(dbConnection);
		ArrayList<Integer> filteredList = queries.filterPriceRange(100000, 200000);
		Map map = new Map(this, new UDim2(), new UDim2(1, 0, 1, 0), queries, filteredList);
	}

}
package database;

import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.DecimalFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.time.DateTimeException;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

public class Queries
{
	private DBConnection dbConnection;
	private SimpleDateFormat simpleDateFormat, storedDateFormat, outputDateFormat;

	public Queries(DBConnection dbConnection)
	{
		this.dbConnection = dbConnection;

		simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd");
		storedDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
		outputDateFormat = new SimpleDateFormat("dd/MM/yyyy");
	}

	public static String formatDatabaseDate(String databaseFormat)
	{
		String dateString = "";
		try
		{
			SimpleDateFormat storedDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm");
			SimpleDateFormat outputDateFormat = new SimpleDateFormat("dd/MM/yyyy");
			Date date = storedDateFormat.parse(databaseFormat);
			dateString = outputDateFormat.format(date);
		} catch (ParseException e)
		{
			e.printStackTrace();
		}
		return dateString;
	}

	public static Date addDays(Date date, int days)
	{
		Calendar cal = Calendar.getInstance();
		cal.setTime(date);
		cal.add(Calendar.DATE, days);
		return cal.getTime();
	}

	public ArrayList<Integer> getAllIDs()
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT ID FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public boolean isValidDate(String date)
	{
		String[] dateProperties = date.split("/");

		if(dateProperties != null && dateProperties.length == 3)
		{
			int year = Integer.parseInt(dateProperties[2]);
			int month = Integer.parseInt(dateProperties[1]);
			int day = Integer.parseInt(dateProperties[0]);
			try
			{
				LocalDate.of(year, month, day);
				return true;
			}
			catch(DateTimeException e)
			{
				return false;
			}
		}
		return false;
	}

	public ArrayList<Integer> filterPriceRange(int lowerLimit, int upperLimit)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT ID FROM LAND WHERE PRICE > ? AND PRICE <? ";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			preparedStatement.setInt(1, lowerLimit);
			preparedStatement.setInt(2, upperLimit);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterPriceRange(ArrayList<Integer> listOfIDs, int lowerLimit, int upperLimit)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") AND PRICE > ? AND PRICE <?";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			preparedStatement.setInt(1, lowerLimit);
			preparedStatement.setInt(2, upperLimit);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}

		return filteredList;
	}

	public ArrayList<Integer> filterPropertyType(ArrayList<Integer> listOfIDs, String[] types)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		String type = getTypeString(types);

		try
		{
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") AND (TYPE LIKE " + type + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterPropertyType(String[] types)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String type = getTypeString(types);
		try
		{
			String sql = "SELECT ID FROM LAND WHERE TYPE LIKE " + type + "";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterPropertyType(ArrayList<Integer> listOfIDs, String type)
	{
		return filterPropertyType(listOfIDs, new String[] { type });
	}

	public ArrayList<Integer> filterPropertyType(String type)
	{
		return filterPropertyType(new String[] { type });
	}

	public ArrayList<Integer> filterCondition(String condition)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT ID FROM LAND WHERE CONDITION LIKE ?";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			preparedStatement.setString(1, condition);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	private String formatDate(String date)
	{
		String[] dateProperties = date.split("/");
		int year1 = Integer.parseInt(dateProperties[2]);
		int month1 = Integer.parseInt(dateProperties[1]);
		int day1 = Integer.parseInt(dateProperties[0]);
		return (year1 + "-" + ((month1 >= 10) ? month1 : "0" + month1) + "-" + ((day1 >= 10) ? day1 : "0" + day1));
	}

	public ArrayList<Integer> filterCondition(ArrayList<Integer> listOfIDs, String[] condition)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String conditionString = "";
			if(condition.length == 1) conditionString = "AND CONDITION LIKE '" + condition[0] + "'";
			else if(condition.length == 2) conditionString =
					"AND (CONDITION LIKE '" + condition[0] + "' OR CONDITION LIKE '" + condition[1] + "')";
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") " + conditionString;
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterCondition(ArrayList<Integer> listOfIDs, String condition)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") AND CONDITION LIKE ?";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			preparedStatement.setString(1, condition);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public String[] getRandomAddresses(int numberOfAddresses)
	{
		ArrayList<Integer> allIDs = getAllIDs();
		Collections.shuffle(allIDs);
		ArrayList<Integer> filteredList = new ArrayList<>();
		for(int i = 0; i <= numberOfAddresses; i++)
			filteredList.add(allIDs.get(i));

		String[] addresses = new String[numberOfAddresses];

		try
		{
			String ids = getIDString(filteredList);
			String sql = "SELECT NAME, STREET, LOCALITY, TOWN, DISTRICT, COUNTY FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			int count = 0;
			while(resultSet.next() & count < numberOfAddresses)
			{
				String name = resultSet.getString("NAME");
				String street = resultSet.getString("STREET");
				String locality = resultSet.getString("LOCALITY");
				String town = resultSet.getString("TOWN");
				String district = resultSet.getString("DISTRICT");
				String county = resultSet.getString("COUNTY");

				addresses[count] = (name + ", " + street + "," + locality + ", " + town + ", " + district + ", "
						+ county);
				count++;
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}

		return addresses;
	}

	public ArrayList<Integer> filterLocation(String postCode)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT POSTCODE,ID FROM LAND WHERE POSTCODE LIKE '%" + postCode + "%'";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				if(resultSet.getString("POSTCODE").startsWith(postCode)) filteredList.add(resultSet.getInt("ID"));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterLocation(ArrayList<Integer> listOfIDs, String postCode)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql =
					"SELECT POSTCODE,ID FROM LAND WHERE ID IN (" + ids + ") AND POSTCODE LIKE '%" + postCode + "%'";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next() && resultSet.getString("POSTCODE").startsWith(postCode))
			{
				filteredList.add(resultSet.getInt("ID"));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	private ArrayList<Integer> filterFormattedDate(String formattedDate1, String formattedDate2)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT ID FROM LAND WHERE DATETIME(DATE) BETWEEN DATE('" + formattedDate1 + "') AND DATE('"
					+ formattedDate2 + "')";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	private ArrayList<Integer> filterFormattedDate(ArrayList<Integer> listOfIDs, String formattedDate1,
			String formattedDate2)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql =
					"SELECT ID FROM LAND WHERE ID IN (" + ids + ") AND DATETIME(DATE) BETWEEN DATE('" + formattedDate1
							+ "') AND DATE('" + formattedDate2 + "')";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterDate(String lowerDate, String upperDate)
	{
		if(isValidDate(lowerDate) && isValidDate(upperDate))
		{
			return filterFormattedDate(formatDate(lowerDate), formatDate(upperDate));
		}
		else return null;
	}

	public ArrayList<Integer> filterDate(ArrayList<Integer> listOfIDs, String lowerDate, String upperDate)
	{
		if(isValidDate(lowerDate) && isValidDate(upperDate))
		{
			return filterFormattedDate(listOfIDs, formatDate(lowerDate), formatDate(upperDate));
		}
		else return null;
	}

	public ArrayList<Integer> filterByCounty(String[] county)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		try
		{
			String sql = "SELECT ID FROM LAND WHERE ";
			for(int i = 0; i < county.length; i++)
				sql += ((i == 0) ? "" : "OR ") + "COUNTY LIKE '" + county[i].toUpperCase() + "' ";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterByCounty(ArrayList<Integer> listOfIDs, String[] county)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") ";
			for(int i = 0; i < county.length; i++)
				sql += ((i == 0) ? "AND (" : "OR ") + "COUNTY LIKE '" + county[i].toUpperCase() + "' ";
			sql += ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<String> getAddressSuggestion(ArrayList<Integer> listOfIDs, String address)
	{
		ArrayList<String> filteredList = new ArrayList<>();
		String[] separatedAddress = address.split(",");
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT NAME, STREET, LOCALITY, TOWN, DISTRICT, COUNTY FROM LAND WHERE ID IN (" + ids + ") ";
			if(separatedAddress.length >= 1)
				sql += " AND NAME LIKE '" + separatedAddress[0].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 2)
				sql += " AND STREET LIKE '" + separatedAddress[1].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 3)
				sql += " AND LOCALITY LIKE '" + separatedAddress[2].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 4)
				sql += " AND TOWN LIKE '" + separatedAddress[3].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 5)
				sql += " AND DISTRICT LIKE '" + separatedAddress[4].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 6)
				sql += " AND COUNTY LIKE '" + separatedAddress[5].toUpperCase().trim() + "' ";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				String name = resultSet.getString("NAME");
				String street = resultSet.getString("STREET");
				String locality = resultSet.getString("LOCALITY");
				String town = resultSet.getString("TOWN");
				String district = resultSet.getString("DISTRICT");
				String county = resultSet.getString("COUNTY");

				filteredList.add(name + ", " + street + "," + locality + ", " + town + ", " + district + ", " + county);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public ArrayList<Integer> filterByAddress(ArrayList<Integer> listOfIDs, String address)
	{
		ArrayList<Integer> filteredList = new ArrayList<>();
		String[] separatedAddress = address.split(",");
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT ID FROM LAND WHERE ID IN (" + ids + ") ";
			if(separatedAddress.length >= 1)
				sql += " AND NAME LIKE '" + separatedAddress[0].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 2)
				sql += " AND STREET LIKE '" + separatedAddress[1].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 3)
				sql += " AND LOCALITY LIKE '" + separatedAddress[2].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 4)
				sql += " AND TOWN LIKE '" + separatedAddress[3].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 5)
				sql += " AND DISTRICT LIKE '" + separatedAddress[4].toUpperCase().trim() + "' ";
			if(separatedAddress.length >= 6)
				sql += " AND COUNTY LIKE '" + separatedAddress[5].toUpperCase().trim() + "' ";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) filteredList.add(resultSet.getInt("ID"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return filteredList;
	}

	public int getAveragePrice()
	{
		int average = - 1;
		try
		{
			String sql = "SELECT AVG(PRICE) FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next())
			{
				average = resultSet.getInt("AVG(PRICE)");
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return average;
	}

	public int getAveragePrice(ArrayList<Integer> listOfIDs)
	{
		int average = - 1;
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT AVG(PRICE) FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next())
			{
				average = resultSet.getInt("AVG(PRICE)");
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return average;
	}

	//Returns an array with the count in each division. The divisions are currently evenly spaced.
	public int[] priceChartingData(int lowerLimit, int higherLimit, int divisions)
	{
		int max = higherLimit;
		int min = lowerLimit;
		int division = ((max - min) / divisions);
		int startingPoint = min;
		int[] data = new int[divisions];
		String sql = "SELECT";
		for(int i = 0; i < divisions; i++)
		{
			sql += getPriceDataString(startingPoint, startingPoint + division) + + i + ((divisions != 1
					&& i != divisions - 1) ? "," : "");
			startingPoint += division;
		}
		sql += " FROM LAND";
		try
		{
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next())
			{
				for(int i = 0; i < divisions; i++)
					data[i] = resultSet.getInt("division" + i);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}

		return data;
	}

	//Returns an array with the count in each type
	public int[] priceChartingData(ArrayList<Integer> listOfIDs, int lowerLimit, int higherLimit, int divisions)
	{
		int max = higherLimit;
		int min = lowerLimit;
		int division = ((max - min) / divisions);
		int startingPoint = min;
		int[] data = new int[divisions];
		String sql = "SELECT";
		String ids = getIDString(listOfIDs);
		for(int i = 0; i < divisions; i++)
		{
			sql += getPriceDataString(startingPoint, startingPoint + division) + i + ((divisions != 1
					&& i != divisions - 1) ? "," : "");
			startingPoint += division;
		}
		sql += " FROM LAND WHERE ID IN (" + ids + ")";
		try
		{
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) for(int i = 0; i < divisions; i++)
				data[i] = resultSet.getInt("division" + i);
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return data;
	}

	public int[] monthChartingData(ArrayList<Integer> listOfIDs)
	{
		int[] data = new int[12];
		try
		{
			String ids = getIDString(listOfIDs);
			String sql = "SELECT SUM( CASE WHEN strftime('%m', DATE) = '01' THEN 1 ELSE 0 END)month1 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '02' THEN 1 ELSE 0 END)month2 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '03' THEN 1 ELSE 0 END)month3 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '04' THEN 1 ELSE 0 END)month4 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '05' THEN 1 ELSE 0 END)month5 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '06' THEN 1 ELSE 0 END)month6\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '07' THEN 1 ELSE 0 END)month7 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '08' THEN 1 ELSE 0 END)month8 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '09' THEN 1 ELSE 0 END)month9 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '10' THEN 1 ELSE 0 END)month10 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '11' THEN 1 ELSE 0 END)month11\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '12' THEN 1 ELSE 0 END)month12 \n" + "from LAND"
					+ " WHERE ID IN (" + ids + ")";

			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			for(int month = 1; month <= 12; month++)
			{
				data[month - 1] = resultSet.getInt("month" + month);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return data;
	}

	public DiscreteData monthSalesDiscreteData(ArrayList<Integer> listOfIDs)
	{
		int[] data = monthChartingData(listOfIDs);
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		return new DiscreteData(data, labels, "Sales by Month");
	}

	public DiscreteData[] monthTypeDiscreteData(ArrayList<Integer> listOfIDs)
	{
		ArrayList<DiscreteData> discreteDatas = new ArrayList<>();
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		try
		{
			String ids = getIDString(listOfIDs);
			String sql = "SELECT TYPE, SUM( CASE WHEN strftime('%m', DATE) = '01' THEN 1 ELSE 0 END)month1 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '02' THEN 1 ELSE 0 END)month2 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '03' THEN 1 ELSE 0 END)month3 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '04' THEN 1 ELSE 0 END)month4 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '05' THEN 1 ELSE 0 END)month5 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '06' THEN 1 ELSE 0 END)month6\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '07' THEN 1 ELSE 0 END)month7 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '08' THEN 1 ELSE 0 END)month8 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '09' THEN 1 ELSE 0 END)month9 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '10' THEN 1 ELSE 0 END)month10 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '11' THEN 1 ELSE 0 END)month11\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '12' THEN 1 ELSE 0 END)month12 \n" + "from LAND"
					+ " WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				String title = resultSet.getString("TYPE");
				int[] data = new int[12];
				for(int month = 1; month <= 12; month++)
				{
					data[month - 1] = resultSet.getInt("month" + month);
				}
				discreteDatas.add(new DiscreteData(data, labels, title));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return discreteDatas.toArray(new DiscreteData[discreteDatas.size()]);
	}

	public DiscreteData[] monthTypeAverageDiscreteData(ArrayList<Integer> listOfIDs)
	{
		ArrayList<DiscreteData> discreteDatas = new ArrayList<>();
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		try
		{
			String ids = getIDString(listOfIDs);
			String sql = "SELECT TYPE, AVG( CASE WHEN strftime('%m', DATE) = '01' THEN PRICE ELSE null END)month1 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '02' THEN PRICE ELSE null END)month2 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '03' THEN PRICE ELSE null END)month3 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '04' THEN PRICE ELSE null END)month4 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '05' THEN PRICE ELSE null END)month5 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '06' THEN PRICE ELSE null END)month6\n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '07' THEN PRICE ELSE null END)month7 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '08' THEN PRICE ELSE null END)month8 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '09' THEN PRICE ELSE null END)month9 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '10' THEN PRICE ELSE null END)month10 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '11' THEN PRICE ELSE null END)month11\n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '12' THEN PRICE ELSE null END)month12 \n" + "from LAND"
					+ " WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				String title = resultSet.getString("TYPE");
				int[] data = new int[12];
				for(int month = 1; month <= 12; month++)
				{
					data[month - 1] = resultSet.getInt("month" + month);
				}
				discreteDatas.add(new DiscreteData(data, labels, title));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return discreteDatas.toArray(new DiscreteData[discreteDatas.size()]);
	}

	public DiscreteData[] monthConditionAverageDiscreteData(ArrayList<Integer> listOfIDs)
	{
		ArrayList<DiscreteData> discreteDatas = new ArrayList<>();
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		try
		{
			String ids = getIDString(listOfIDs);
			String sql =
					"SELECT CONDITION, AVG( CASE WHEN strftime('%m', DATE) = '01' THEN PRICE ELSE null END)month1 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '02' THEN PRICE ELSE null END)month2 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '03' THEN PRICE ELSE null END)month3 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '04' THEN PRICE ELSE null END)month4 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '05' THEN PRICE ELSE null END)month5 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '06' THEN PRICE ELSE null END)month6\n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '07' THEN PRICE ELSE null END)month7 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '08' THEN PRICE ELSE null END)month8 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '09' THEN PRICE ELSE null END)month9 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '10' THEN PRICE ELSE null END)month10 \n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '11' THEN PRICE ELSE null END)month11\n"
							+ ",AVG( CASE WHEN strftime('%m', DATE) = '12' THEN PRICE ELSE null END)month12 \n"
							+ "from LAND" + " WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				String title = resultSet.getString("CONDITION");
				int[] data = new int[12];
				for(int month = 1; month <= 12; month++)
				{
					data[month - 1] = resultSet.getInt("month" + month);
				}
				discreteDatas.add(new DiscreteData(data, labels, title));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return discreteDatas.toArray(new DiscreteData[discreteDatas.size()]);
	}

	public DiscreteData[] monthConditionDiscreteData(ArrayList<Integer> listOfIDs)
	{
		ArrayList<DiscreteData> discreteDatas = new ArrayList<>();
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		try
		{
			String ids = getIDString(listOfIDs);
			String sql = "SELECT CONDITION, SUM( CASE WHEN strftime('%m', DATE) = '01' THEN 1 ELSE 0 END)month1 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '02' THEN 1 ELSE 0 END)month2 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '03' THEN 1 ELSE 0 END)month3 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '04' THEN 1 ELSE 0 END)month4 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '05' THEN 1 ELSE 0 END)month5 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '06' THEN 1 ELSE 0 END)month6\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '07' THEN 1 ELSE 0 END)month7 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '08' THEN 1 ELSE 0 END)month8 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '09' THEN 1 ELSE 0 END)month9 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '10' THEN 1 ELSE 0 END)month10 \n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '11' THEN 1 ELSE 0 END)month11\n"
					+ ",SUM( CASE WHEN strftime('%m', DATE) = '12' THEN 1 ELSE 0 END)month12 \n" + "from LAND"
					+ " WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				String title = resultSet.getString("CONDITION");
				int[] data = new int[12];
				for(int month = 1; month <= 12; month++)
				{
					data[month - 1] = resultSet.getInt("month" + month);
				}
				discreteDatas.add(new DiscreteData(data, labels, title));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return discreteDatas.toArray(new DiscreteData[discreteDatas.size()]);
	}

	public int[] monthAverageChartingData(ArrayList<Integer> listOfIDs)
	{
		int[] data = new int[12];
		try
		{
			String ids = getIDString(listOfIDs);
			String sql = "SELECT AVG( CASE WHEN strftime('%m', DATE) = '01' THEN PRICE ELSE null END)month1 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '02' THEN PRICE ELSE null END)month2 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '03' THEN PRICE ELSE null END)month3 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '04' THEN PRICE ELSE null END)month4 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '05' THEN PRICE ELSE null END)month5 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '06' THEN PRICE ELSE null END)month6\n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '07' THEN PRICE ELSE null END)month7 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '08' THEN PRICE ELSE null END)month8 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '09' THEN PRICE ELSE null END)month9 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '10' THEN PRICE ELSE null END)month10 \n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '11' THEN PRICE ELSE null END)month11\n"
					+ ",AVG( CASE WHEN strftime('%m', DATE) = '12' THEN PRICE ELSE null END)month12 \n" + "from LAND"
					+ " WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			for(int month = 1; month <= 12; month++)
			{
				data[month - 1] = resultSet.getInt("month" + month);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return data;
	}

	public DiscreteData monthAverageDiscretData(ArrayList<Integer> listOfIDs)
	{
		int[] data = monthAverageChartingData(listOfIDs);
		String[] labels = new String[] { "January", "February", "March", "April", "May", "June", "July", "August",
				"September", "October", "November", "December" };
		return new DiscreteData(data, labels, "Average Price by Month");
	}

	public DiscreteData dateAmountDiscreteData(ArrayList<Integer> listOfIDs, int divisions)
	{
		int[] data = new int[divisions];
		String[] labels = new String[divisions];

		try
		{
			String earliestDate = simpleDateFormat.format(outputDateFormat.parse(getEarliestDate(listOfIDs)));
			String latestDate = simpleDateFormat.format(outputDateFormat.parse(getLatestDate(listOfIDs)));
			String ids = getIDString(listOfIDs);

			Date startDate = simpleDateFormat.parse(earliestDate);
			Date endDate = simpleDateFormat.parse(latestDate);
			long diff = endDate.getTime() - startDate.getTime();
			diff = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
			int division = (int) (diff / divisions);
			String sql = "SELECT ";
			for(int divisionCount = 1; divisionCount <= divisions; divisionCount++)
			{
				sql += ((divisionCount != 1) ? "," : "") + " SUM(CASE WHEN DATE BETWEEN DATETIME('" + earliestDate
						+ "', '+" + (division - 1) * divisionCount + " days') AND DATETIME('" + earliestDate + "', '+"
						+ division * divisionCount + " days') THEN 1 ELSE 0 END)division" + divisionCount;
				labels[divisionCount - 1] = simpleDateFormat.format(addDays(startDate, (divisionCount * division)));
			}

			sql += " FROM LAND WHERE ID IN (" + ids + ")";

			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) for(int i = 1; i <= divisions; i++)
				data[i - 1] = resultSet.getInt("division" + i);

		}
		catch(Exception e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return new DiscreteData(data, labels, "Number of Properties Sold");
	}

	public DiscreteData dateAverageDiscreteData(ArrayList<Integer> listOfIDs, int divisions)
	{
		int[] data = new int[divisions];
		String[] labels = new String[divisions];

		try
		{
			String earliestDate = simpleDateFormat.format(outputDateFormat.parse(getEarliestDate(listOfIDs)));
			String latestDate = simpleDateFormat.format(outputDateFormat.parse(getLatestDate(listOfIDs)));
			String ids = getIDString(listOfIDs);

			Date startDate = simpleDateFormat.parse(earliestDate);
			Date endDate = simpleDateFormat.parse(latestDate);
			long diff = endDate.getTime() - startDate.getTime();
			diff = TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
			int division = (int) (diff / divisions);
			String sql = "SELECT ";
			for(int divisionCount = 1; divisionCount <= divisions; divisionCount++)
			{
				sql += ((divisionCount != 1) ? "," : "") + " AVG(CASE WHEN DATE BETWEEN DATETIME('" + earliestDate
						+ "', '+" + (division - 1) * divisionCount + " days') AND DATETIME('" + earliestDate + "', '+"
						+ division * divisionCount + " days') THEN PRICE ELSE null END)division" + divisionCount;
				labels[divisionCount - 1] = simpleDateFormat.format(addDays(startDate, (divisionCount * division)));
			}

			sql += " FROM LAND WHERE ID IN (" + ids + ")";

			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) for(int i = 1; i <= divisions; i++)
				data[i - 1] = resultSet.getInt("division" + i);

		}
		catch(Exception e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return new DiscreteData(data, labels, "Average Price of Sold Properties");
	}

	private int[] getDataFromSQL(String sql, int[] data)
	{
		try
		{
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) for(int i = 0; i < data.length; i++)
				data[i] = resultSet.getInt("division" + i);
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return data;
	}

	private String getPriceDataString(int lowerPrice, int higherPrice)
	{
		return " SUM(CASE WHEN PRICE >" + lowerPrice + " AND PRICE<" + higherPrice + " THEN 1 ELSE 0 END) division";
	}

	public int[] propertyTypeChartingData(ArrayList<Integer> listOfIDs, String[] types)
	{
		int[] data = new int[types.length];
		String ids = getIDString(listOfIDs);
		String sql = "SELECT" + getPropertyTypeString(types) + " FROM LAND WHERE ID IN (" + ids + ")";
		return getDataFromSQL(sql, data);
	}

	public int[] propertyTypeChartingData(String[] types)
	{
		int[] data = new int[types.length];
		String sql = "SELECT" + getPropertyTypeString(types) + " FROM LAND";
		return getDataFromSQL(sql, data);
	}

	private String getPropertyTypeString(String[] types)
	{
		String s = "";
		for(int i = 0; i < types.length; i++)
		{
			s += " SUM(CASE WHEN TYPE LIKE '" + types[i] + "' THEN 1 ELSE 0 END) division" + i + ((types.length != 1
					&& i != types.length - 1) ? "," : "");
		}
		return s;
	}

	public int[] conditionChartingData()
	{
		int[] data = new int[2];
		String sql = "SELECT SUM(CASE WHEN CONDITION LIKE 'Established' THEN 1 ELSE 0 END) division0,"
				+ " SUM(CASE WHEN CONDITION LIKE 'Newly Built' THEN 1 ELSE 0 END)division1 FROM LAND";
		return getDataFromSQL(sql, data);
	}

	public int[] conditionChartingData(ArrayList<Integer> listOfIDs)
	{
		int[] data = new int[2];
		String ids = getIDString(listOfIDs);
		String sql = "SELECT SUM(CASE WHEN CONDITION LIKE 'Established' THEN 1 ELSE 0 END) division0,"
				+ " SUM(CASE WHEN CONDITION LIKE 'Newly Built' THEN 1 ELSE 0 END)division1 FROM LAND WHERE ID IN ("
				+ ids + ")";
		return getDataFromSQL(sql, data);
	}

	public ArrayList<double[]> getCoordinates()
	{
		ArrayList<double[]> coordinates = new ArrayList<>();
		try
		{
			String sql = "SELECT LATITUDE,LONGITUDE FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				double[] coordinate = new double[] { resultSet.getDouble("LATITUDE"),
						resultSet.getDouble("LONGITUDE") };
				coordinates.add(coordinate);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return coordinates;
	}

	public ArrayList<double[]> getCoordinates(ArrayList<Integer> listOfIDs)
	{
		ArrayList<double[]> coordinates = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT LATITUDE,LONGITUDE FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				double[] coordinate = new double[] { resultSet.getDouble("LATITUDE"),
						resultSet.getDouble("LONGITUDE") };
				coordinates.add(coordinate);
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return coordinates;
	}

	public String[] getAllCounties()
	{
		ArrayList<String> listOfCounties = new ArrayList<>();
		try
		{
			String sql = "SELECT DISTINCT COUNTY FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next()) listOfCounties.add(resultSet.getString("COUNTY"));
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return listOfCounties.toArray(new String[listOfCounties.size()]);
	}

	public String getEarliestDate(ArrayList<Integer> listOfIDs)
	{
		String date = "";
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT MIN(DATE) FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) date = resultSet.getString("MIN(DATE)");
			date = outputDateFormat.format(storedDateFormat.parse(date));
		}
		catch(Exception e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return date;
	}

	public String getLatestDate(ArrayList<Integer> listOfIDs)
	{
		String date = "";
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT MAX(DATE) FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) date = resultSet.getString("MAX(DATE)");
			date = outputDateFormat.format(storedDateFormat.parse(date));
		}
		catch(Exception e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return date;
	}

	public int getMinPrice()
	{
		int min = - 1;
		try
		{
			String sql = "SELECT MIN(PRICE) FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) min = resultSet.getInt("MIN(PRICE)");
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return min;
	}

	public int getMinPrice(ArrayList<Integer> listOfIDs)
	{
		int min = - 1;
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT MIN(PRICE) FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) min = resultSet.getInt("MIN(PRICE)");
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return min;
	}

	public int getMaxPrice()
	{
		int max = - 1;
		try
		{
			String sql = "SELECT MAX(PRICE) FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) max = resultSet.getInt("MAX(PRICE)");
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return max;
	}

	public int getMaxPrice(ArrayList<Integer> listOfIDs)
	{
		int max = - 1;
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT MAX(PRICE) FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			if(resultSet.next()) max = resultSet.getInt("MAX(PRICE)");
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return max;
	}

	public int getTotalSize(ArrayList<Integer> list)
	{
		return list.size();
	}

	public int getTotalSize()
	{
		int size = - 1;
		try
		{
			String sql = "SELECT MAX(ID) FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			size = resultSet.getInt("MAX(ID)") + 1;
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return size;
	}

	public Land[] getLandObjects()
	{
		ArrayList<Land> landList = new ArrayList<>();
		try
		{
			String sql = "SELECT * FROM LAND";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				int price = resultSet.getInt("PRICE");
				String date = resultSet.getString("DATE");
				String postCode = resultSet.getString("POSTCODE");
				double latitude = resultSet.getDouble("LATITUDE");
				double longitude = resultSet.getDouble("LONGITUDE");
				String type = resultSet.getString("TYPE");
				String condition = resultSet.getString("CONDITION");
				String name = resultSet.getString("NAME");
				String street = resultSet.getString("STREET");
				String locality = resultSet.getString("LOCALITY");
				String town = resultSet.getString("TOWN");
				String district = resultSet.getString("DISTRICT");
				String county = resultSet.getString("COUNTY");
				landList.add(
						new Land(price, date, postCode, latitude, longitude, type, condition, name, street, locality,
								town, district, county));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return landList.toArray(new Land[] {});
	}

	public Land[] getLandObjects(ArrayList<Integer> listOfIDs)
	{
		ArrayList<Land> landList = new ArrayList<>();
		String ids = getIDString(listOfIDs);
		try
		{
			String sql = "SELECT * FROM LAND WHERE ID IN (" + ids + ")";
			PreparedStatement preparedStatement = dbConnection.prepareStatement(sql);
			ResultSet resultSet = preparedStatement.executeQuery();
			while(resultSet.next())
			{
				int price = resultSet.getInt("PRICE");
				String date = resultSet.getString("DATE");
				String postCode = resultSet.getString("POSTCODE");
				double latitude = resultSet.getDouble("LATITUDE");
				double longitude = resultSet.getDouble("LONGITUDE");
				String type = resultSet.getString("TYPE");
				String condition = resultSet.getString("CONDITION");
				String name = resultSet.getString("NAME");
				String street = resultSet.getString("STREET");
				String locality = resultSet.getString("LOCALITY");
				String town = resultSet.getString("TOWN");
				String district = resultSet.getString("DISTRICT");
				String county = resultSet.getString("COUNTY");
				landList.add(
						new Land(price, date, postCode, latitude, longitude, type, condition, name, street, locality,
								town, district, county));
			}
		}
		catch(SQLException e)
		{
			System.err.println(e.getClass().getName() + ": " + e.getMessage());
		}
		return landList.toArray(new Land[] {});
	}

	public String getIDString(ArrayList<Integer> listOfIDs)
	{
		String id = "";
		if(listOfIDs.size() > 0)
		{
			List<String> list = listOfIDs.stream().map(Object::toString).collect(Collectors.toList());
			id = String.join(",", list);
		}
		return id;
	}

	private String getTypeString(String[] types)
	{
		if(types.length > 0)
		{
			String s = "'" + types[0] + "'";
			for(int i = 1; i < types.length; i++)
				s += " OR TYPE LIKE" + "'" + types[i] + "'";
			return s;
		}
		else return "";
	}

	public DiscreteData propertyTypeDiscreteData(String[] types)
	{
		int[] data = new int[types.length];
		for(int i = 0; i < data.length; i++)
		{
			data[i] = filterPropertyType(types[i]).size();
		}
		return new DiscreteData(data, types, "Type of Property Sold");
	}

	public DiscreteData propertyTypeDiscreteData(ArrayList<Integer> listOfIDs, String[] types)
	{
		int[] data = new int[types.length];
		for(int i = 0; i < data.length; i++)
		{
			data[i] = filterPropertyType(listOfIDs, types[i]).size();
		}
		return new DiscreteData(data, types, "Type of Property Sold");
	}

	public DiscreteData conditionDiscreteData()
	{
		int[] data = new int[] { filterCondition("Established").size(), filterCondition("Newly Built").size() };
		return new DiscreteData(data, new String[] { "Established", "Newly Built" }, "Condition of Sold Properties");
	}

	public DiscreteData conditionDiscreteData(ArrayList<Integer> listOfIDs)
	{
		int[] data = new int[] { filterCondition(listOfIDs, "Established").size(),
				filterCondition(listOfIDs, "Newly Built").size() };
		return new DiscreteData(data, new String[] { "Established", "Newly Built" }, "Condition of Sold Properties");
	}

	public DiscreteData priceDiscreteData(ArrayList<Integer> listOfIDS, int lowerLimit, int higherLimit, int divisions)
	{
		if(higherLimit > 2000000) higherLimit = 2000000;
		int[] data = priceChartingData(listOfIDS, lowerLimit, higherLimit, divisions);
		String[] labels = new String[divisions];
		int divisionSize = (higherLimit - lowerLimit) / divisions;
		int startingPrice = lowerLimit + divisionSize;
		DecimalFormat numberFormat = new DecimalFormat("##.#");
		DecimalFormat millionFormat = new DecimalFormat("##.###");
		for(int i = 0; i < divisions; i++)
		{
			if(startingPrice > 1000000) labels[i] = "" + millionFormat.format((double) startingPrice / 1000000.0) + "m";
			else if(startingPrice > 1000) labels[i] = "" + numberFormat.format((double) startingPrice / 1000.0) + "k";
			else labels[i] = "" + startingPrice;
			startingPrice += divisionSize;
		}
		return new DiscreteData(data, labels, "Sale Prices of Properties");
	}

	public DiscreteData priceDiscreteData(int lowerLimit, int higherLimit, int divisions)
	{
		if(higherLimit > 2000000) higherLimit = 2000000;
		int[] data = priceChartingData(lowerLimit, higherLimit, divisions);
		String[] labels = new String[divisions];
		int divisionSize = (higherLimit - lowerLimit) / divisions;
		int startingPrice = lowerLimit + divisionSize;
		DecimalFormat numberFormat = new DecimalFormat("##.#");
		DecimalFormat millionFormat = new DecimalFormat("##.###");
		for(int i = 0; i < divisions; i++)
		{
			if(startingPrice > 1000000) labels[i] = "" + millionFormat.format((double) startingPrice / 1000000.0) + "m";
			else if(startingPrice > 1000) labels[i] = "" + numberFormat.format((double) startingPrice / 1000.0) + "k";
			else labels[i] = "" + startingPrice;
			startingPrice += divisionSize;
		}
		return new DiscreteData(data, labels, "Sale Prices of Properties");
	}

	public HashMap<String, String> getMapDisplayInfo(ArrayList<Integer> listOfIDs)
	{

		LinkedHashMap<String, String> info = new LinkedHashMap<>();
		info.put("Number of Properties", "" + listOfIDs.size());
		String[] types = { Land.TERRACED, Land.DETACHED, Land.SEMI_DETACHED, Land.FLATS_MAISONETTES, Land.OTHER };
		int[] typeData = propertyTypeChartingData(listOfIDs, types);
		for(int i = 0; i < types.length; i++)
		{
			info.put(types[i], "" + typeData[i]);
		}
		int[] conditionData = conditionChartingData(listOfIDs);
		info.put("Established", "" + conditionData[0]);
		info.put("Newly Built", "" + conditionData[1]);
		info.put("Average Price", "" + getAveragePrice(listOfIDs));
		info.put("Maximum Price", "" + getMaxPrice(listOfIDs));
		info.put("Minimum Price", "" + getMinPrice(listOfIDs));
		return info;
	}

}

package database;

import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;

public class CoordinateConverter
{
	//Converts postcode to coordinated. Latitude is in index 0, while Longitude is in index 1.
	public static double[] convertPostcode(String postCode)
	{
		postCode = postCode.replaceAll("\\s", "");
		double latitude = 0;
		double longitude = 0;
		try
		{
			URL url = new URL("https://api.postcodes.io/postcodes/" + postCode);
			HttpURLConnection connection = (HttpURLConnection) url.openConnection();
			connection.setRequestMethod("GET");
			connection.connect();
			int responseCode = connection.getResponseCode();
			if(responseCode == 200)
			{
				JSONParser parser = new JSONParser();
				InputStream inputStream = connection.getInputStream();
				JSONObject jsonObject = (JSONObject) parser
				.parse(new InputStreamReader(inputStream));
				jsonObject = (JSONObject) jsonObject.get("result");
				latitude = (double) jsonObject.get("latitude");
				longitude = (double) jsonObject.get("longitude");
			}
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
		return new double[] { latitude, longitude };
	}
}
package database;

import java.io.IOException;
import java.sql.*;
import java.util.HashMap;

public class DBConnection {
	private static final String SUCCESS_MESSAGE = "Connected to database successfully";
	private static final String INITILIAZE_MESSAGE = "Initializing database...";
	private static final String DATABASE_EXISTS = "Database already exists, will not build a new one.";
	private static final String FINISHED_DATABASE = "Database has been built with %d queries.\n Took %.2f seconds to build.\n";
	// SQL statement strings
	private static final String CREATE_LAND_TABLE = "CREATE TABLE IF NOT EXISTS LAND " +
													"(ID INT PRIMARY KEY	NOT NULL," +
													" PRICE			INT		NOT NULL," +
													" DATE     		TEXT	NOT NULL," +
													" POSTCODE		TEXT	NOT NULL," +
													" LATITUDE      DOUBLE PRECISION		NOT NULL," +
													" LONGITUDE     DOUBLE PRECISION		NOT NULL," +
													" TYPE			TEXT	NOT NULL," +
													" CONDITION     TEXT	NOT NULL," +
													" NAME     		TEXT	NOT NULL," +
													" STREET		TEXT," +
													" LOCALITY 		TEXT," +
													" TOWN			TEXT	NOT NULL," +
													" DISTRICT		TEXT	NOT NULL," +
													" COUNTY		TEXT	NOT NULL);";
	private static final String INSERT_EXPRESSION = "INSERT INTO LAND";
	
	private static HashMap<String, String> expandedValue = new HashMap<String, String> ();
	
	private Connection connection = null;
	private Statement statement = null;
	
	public DBConnection () {
		expandedValue.put("D", "Detached");
		expandedValue.put("S", "Semi-Detached");
		expandedValue.put("T", "Terraced");
		expandedValue.put("F", "Flats/Maisonettes");
		expandedValue.put("O", "Other");
		
		expandedValue.put("Y", "Newly Built");
		expandedValue.put("N", "Established");
		
		loadDB();
	}
	
	public void loadDB () {
		try {
			Class.forName("org.sqlite.JDBC");
			connection = DriverManager.getConnection("jdbc:sqlite:land.db");
			statement = connection.createStatement();

			DatabaseMetaData dbm = connection.getMetaData();
			ResultSet tables = dbm.getTables(null, null, "LAND", null);
			if (tables.next()) {
				System.out.println(DATABASE_EXISTS);
			} else {
				buildDB();
			}
		} catch (Exception e) {
			e.printStackTrace();
			System.exit(0);
		}
		System.out.println(SUCCESS_MESSAGE);
	}
	
	public void buildDB () throws SQLException {
		long start = System.currentTimeMillis();
		System.out.println(INITILIAZE_MESSAGE);
		statement.executeUpdate(CREATE_LAND_TABLE);
		try {
			LineReader reader = new LineReader("input.csv");
			int id;
			for (id = 0; reader.hasNextLine(); id++) {
				String[] newLine = reader.nextLine();
				
				String insertSQL = INSERT_EXPRESSION + " VALUES (" + id;
				for (int i = 0; i < newLine.length; i++) {
					String formattedValue = i == 5 || i == 6 ? expandedValue.get(newLine[i]) : newLine[i];
					formattedValue = i != 0 ? "'" + formattedValue + "'" : formattedValue;
					
					insertSQL = insertSQL + ", " + formattedValue;
				}
				insertSQL = insertSQL + ");";
				statement.executeUpdate(insertSQL);
			}
			long end = System.currentTimeMillis();
			System.out.printf(FINISHED_DATABASE, id + 1, (double) (end - start) / 1000.0);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public PreparedStatement prepareStatement(String sql) throws SQLException {
		return connection.prepareStatement(sql);
	}
}package database;

import java.util.HashMap;
import java.util.LinkedHashMap;

public class Land
{

    public static final String DETACHED = "Detached";
    public static final String SEMI_DETACHED = "Semi-Detached";
    public static final String TERRACED = "Terraced";
    public static final String FLATS_MAISONETTES = "Flats/Maisonettes";
    public static final String OTHER = "Other";

    public static final String NEWLY_BUILT = "Newly Built";
    public static final String ESTABLISHED = "Established";

    private int price;
    private String dateOfSale, postcode, propertyType, condition, numberOrName, street, locality, town, district, county;
    private double latitude, longitude;

    public Land(int price, String date, String postcode, double latitude, double longitude,
                String type, String condition, String numberOrName, String street, String locality,
                String town, String district, String county)
    {
        this.price = price;
        this.dateOfSale = date;
        this.postcode = postcode;
        this.latitude = latitude;
        this.longitude = longitude;
        this.propertyType = type;
        this.condition = condition;
        this.numberOrName = numberOrName;
        this.street = street;
        this.locality = locality;
        this.town = town;
        this.district = district;
        this.county = county;
    }

    public HashMap<String, Object> getProperties()
    {
        LinkedHashMap<String, Object> map = new LinkedHashMap<>();
        map.put("Price", "" + String.valueOf(price));
        map.put("Date Of Sale", Queries.formatDatabaseDate(dateOfSale));
        map.put("Postcode", postcode);
        map.put("Type", propertyType);
        map.put("Condition", condition);
        map.put("Number/Name", numberOrName);
        map.put("Street", street);
        map.put("Locality", locality);
        map.put("Town", town);
        map.put("District", district);
        map.put("County", county);
        return map;
    }

    @Override
    public String toString()
    {
        return "" + price + ",\n" + dateOfSale + ",\n" + postcode + ",\n" + propertyType
                + ",\n" + condition + ",\n" + numberOrName + " " + street + (!street.equals("") ?
                ",\n" :
                "") + locality + (!locality.equals("") ? ",\n" : "") + town + (!town.equals("") ?
                ",\n" :
                "") + district + (!district.equals("") ? ",\n" : "") + county + ". ";
    }

    public String getAddress()
    {
        String address = "";
        address += numberOrName + ", ";
        address += street + ", ";
        address += locality + ", ";
        address += town + ", ";
        address += district + ", ";
        address += county;

        return address;
    }

    public int getPrice()
    {
        return this.price;
    }

    public String getSaleDate()
    {
        return this.dateOfSale;
    }

    public String getPostCode()
    {
        return this.postcode;
    }

    public double getLatitude()
    {
        return this.latitude;
    }

    public double getLongitude()
    {
        return this.longitude;
    }

    public String getPropertyType()
    {
        return this.propertyType;
    }

    public String getOldOrNew()
    {
        return this.condition;
    }

    public String getNumberOrName()
    {
        return this.numberOrName;
    }

    public String getStreet()
    {
        return this.street;
    }

    public String getLocality()
    {
        return this.locality;
    }

    public String getTown()
    {
        return this.town;
    }

    public String getDistrict()
    {
        return this.district;
    }

    public String getCounty()
    {
        return this.county;
    }
}
package database;

public class DiscreteData
{
    public int[] data;
    public String[] labels;
    public String title;

    public DiscreteData(int[] data, String[] labels, String title)
    {
        this.data = data;
        this.labels = labels;
        this.title = title;
    }

    public int[] getData() {return data;}

    public String[] getLabels() {return labels;}

    public String getTitle() {return title;}
}
package database;

import java.io.IOException;
import java.io.File;
import java.util.Scanner;
import java.util.regex.Pattern;
import java.util.regex.Matcher;

public class LineReader {
	private static final String VALUE_REGEX = "\"(%s)\",";
	private static final String[] REGULAR_EXPRESSIONS = {
		"\\{[A-Z0-9-]+\\}",																	// Unique Identifier
		"\\d+",																				// Price
		"((19|20)\\d{2})-([0]?[1-9]|[1][0-2])-([3][01]|[12][0-9]|[0]?[1-9])\\s[0:]{5}",		// Date (YYYY-MM-DD 00:00)
		"[A-Z0-9]+\\s[A-Z0-9]+",															// Post code
		"D|S|T|F|O",																		// Property Type
		"Y|N",																				// Condition
		"[A-Z0-9 ,-]*"																		// Other fields
	};
	private static final int UNIQUE_INDEX = 6;
	private static final int[] CORRESPONDS_TO = {1,2,3,0,0,4,5,7,9,10,11,12,13};
	
	private Scanner reader = null;
	
	LineReader (String filePath) throws IOException {
		reader = new Scanner (new File (filePath));
	}
	
	public String[] nextLine () {
		String line = reader.nextLine();
		String[] readValues = new String[16];
		for (int i = 0; i < readValues.length; i++) {
			String pattern = i < UNIQUE_INDEX ? REGULAR_EXPRESSIONS[i] : REGULAR_EXPRESSIONS[UNIQUE_INDEX];
			pattern = String.format(VALUE_REGEX, pattern);
			Matcher matcher = Pattern.compile(pattern).matcher(line);
			if (matcher.find()) {
				readValues[i] = matcher.group(1);
			} else {
				readValues[i] = "";
			}

			line = line.replaceFirst(pattern, "");
		}
		
		String[] values = new String [13];
		for (int i = 0; i < values.length; i++) {
			if (i < 3 || i > 4) {
				values[i] = readValues[CORRESPONDS_TO[i]];
				values[i] = values[i].equals("A") ? "" : values[i];
			} else {
				double[] coords = CoordinateConverter.convertPostcode(values[2]);
				values[3] = Double.toString(coords[0]);
				values[4] = Double.toString(coords[1]);
				i = 4;
			}
		}
		return values;
	}
	
	public boolean hasNextLine () {
		return reader.hasNextLine();
	}
}
